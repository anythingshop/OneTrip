<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>One Trip - Balance System Preview</title>
    <style>
        body { margin: 0; overflow: hidden; background: #111; }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            color: white;
            text-align: center;
            padding: 10px;
            font-family: Arial, sans-serif;
            z-index: 100;
            pointer-events: none;
        }
        #controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px;
            font-family: Arial, sans-serif;
            border-radius: 5px;
        }
        #balanceUI {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px;
            font-family: Arial, sans-serif;
            border-radius: 5px;
        }
        #pickupControls {
            position: absolute;
            left: 10px;
            top: 60px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px;
            font-family: Arial, sans-serif;
            border-radius: 5px;
            z-index: 1000;
        }
        select, button, input {
            margin: 5px;
            padding: 5px;
        }
        #balanceMeter {
            width: 200px;
            height: 10px;
            background: rgba(255,255,255,0.3);
            border-radius: 5px;
            margin-top: 5px;
            position: relative;
        }
        #balanceIndicator {
            position: absolute;
            width: 6px;
            height: 100%;
            background: white;
            border-radius: 3px;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
        }
        .balanceZone {
            position: absolute;
            width: 20%;
            height: 100%;
            background: rgba(76,175,80,0.3);
            top: 0;
            left: 40%;
        }
        #balanceDirection {
            margin-top: 5px;
            font-weight: bold;
            text-align: center;
        }
        .bagCategory {
            margin-top: 10px;
            border-top: 1px solid #444;
            padding-top: 5px;
        }
        #carriedBags {
            margin-top: 10px;
            color: #4CAF50;
        }
    </style>
</head>
<body>
    <div id="info">Loading models...</div>
    <div id="controls">
        <div>
            <label for="upperBodyAnim">Upper Body: </label>
            <select id="upperBodyAnim"></select>
        </div>
        <div>
            <label for="lowerBodyAnim">Lower Body: </label>
            <select id="lowerBodyAnim"></select>
        </div>
        <button id="gameView">Game View</button>
        <button id="resetView">Reset View</button>
    </div>
    
    <div id="pickupControls">
        <h3>Pickup Actions</h3>
        
        <div class="bagCategory">
            <h4>Light Bags:</h4>
            <button id="pickupLowLightBtn">Pickup Low Light</button>
            <button id="pickupHighLightBtn">Pickup High Light</button>
        </div>
        
        <div class="bagCategory">
            <h4>Medium Bags:</h4>
            <button id="pickupLowMediumBtn">Pickup Low Medium</button>
            <button id="pickupHighMediumBtn">Pickup High Medium</button>
        </div>
        
        <div class="bagCategory">
            <h4>Heavy Bags:</h4>
            <button id="pickupLowHeavyBtn">Pickup Low Heavy</button>
            <button id="pickupHighHeavyBtn">Pickup High Heavy</button>
        </div>
        
        <div class="bagCategory">
            <h4>Hand Controls:</h4>
            <button id="attachLeftHandBtn">Use Left Hand</button>
            <button id="attachRightHandBtn">Use Right Hand</button>
            <button id="detachAllBagsBtn">Drop All Bags</button>
        </div>
        
        <div id="carriedBags">
            <h4>Currently Carrying:</h4>
            <div id="leftHandStatus">Left Hand: Empty</div>
            <div id="rightHandStatus">Right Hand: Empty</div>
        </div>
    </div>
    
    <div id="balanceUI">
        <h3>Balance System Preview</h3>
        <div>
            <label for="balanceSlider">Balance (0-1): </label>
            <input type="range" id="balanceSlider" min="0" max="100" value="50">
            <span id="balanceValue">0.5</span>
        </div>
        <div id="balanceMeter">
            <div class="balanceZone"></div>
            <div id="balanceIndicator"></div>
        </div>
        <div id="balanceDirection">Balanced</div>
        <div>
            <button id="toggleBalance">Toggle Balance Effect</button>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.147.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.147.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.147.0/examples/js/loaders/GLTFLoader.js"></script>

    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        
        // Camera setup
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.set(0, 10, 30);
        
        // Renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);
        
        // Controls for testing
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.target.set(0, 2, 0);
        controls.update();
        
        // Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(5, 10, 5);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        scene.add(directionalLight);
        
        // Ground
        const groundGeometry = new THREE.PlaneGeometry(200, 200);
        const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x7CFC00 });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);
        
        // Grid helper
        const gridHelper = new THREE.GridHelper(200, 200);
        scene.add(gridHelper);
        
        // Create text labels for each model
        function createLabel(text, position) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 64;
            
            context.fillStyle = 'rgba(0,0,0,0.7)';
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            context.font = '24px Arial';
            context.fillStyle = 'white';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(text, canvas.width/2, canvas.height/2);
            
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.MeshBasicMaterial({
                map: texture,
                transparent: true,
                side: THREE.DoubleSide
            });
            
            const geometry = new THREE.PlaneGeometry(5, 1.25);
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(position.x, position.y + 5, position.z);
            mesh.lookAt(camera.position);
            
            scene.add(mesh);
            return mesh;
        }

        // Add a path/driveway
        function createDriveway() {
            const pathGeometry = new THREE.PlaneGeometry(5, 50);
            const pathMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xBDBDBD,
                roughness: 0.9
            });
            const path = new THREE.Mesh(pathGeometry, pathMaterial);
            path.rotation.x = -Math.PI / 2;
            path.position.set(0, 0.02, 5); // Slightly above ground to prevent z-fighting
            path.receiveShadow = true;
            scene.add(path);
        }
        createDriveway();

        // Models to load with adjusted positions
        const models = [
            // Character positioned near the car
            { name: 'Character', file: './onetrip_maincharacter.glb', position: [-15, 0, -20], scale: 0.5, rotationY: 0 },
            
            // Car positioned at the beginning of the path
            { name: 'Car', file: './car.glb', position: [-5, 0, -20], scale: 0.5, rotationY: Math.PI/2 },
            
            // House positioned at the end of the path (far in front)
            { name: 'House', file: './house.glb', position: [0, 0, 30], scale: 0.5, rotationY: Math.PI },
            
            // Bags ON TOP of the car - moved further back (more negative Z)
            { name: 'Car Bag 1 (Light)', file: './newbag.glb', position: [-5, 3.5, -21], scale: 0.3, rotationY: 0, weight: 'light' },
            { name: 'Car Bag 2 (Medium)', file: './bag2.glb', position: [-5, 3.5, -22], scale: 0.4, rotationY: Math.PI/4, weight: 'medium' },
            
            // Bags on the GROUND near character
            { name: 'Ground Bag 1 (Medium)', file: './newbag.glb', position: [-13, 0, -19], scale: 0.4, rotationY: 0, weight: 'medium' },
            { name: 'Ground Bag 2 (Heavy)', file: './bag2.glb', position: [-14, 0, -21], scale: 0.5, rotationY: Math.PI/4, weight: 'heavy' },
            
            // Environment objects properly spaced along the path
            { name: 'Tree', file: './tree.glb', position: [-10, 0, 0], scale: 0.5, rotationY: 0 },
            { name: 'Tree 2', file: './tree.glb', position: [10, 0, 10], scale: 0.4, rotationY: Math.PI/3 },
            { name: 'Rocks', file: './rocks.glb', position: [5, 0, -5], scale: 0.5, rotationY: 0 },
            { name: 'Leaves', file: './leaves.glb', position: [2, 0, 15], scale: 0.5, rotationY: 0 }
        ];

        // Animation variables
        let mixer;
        let animations = [];
        let upperBodyActions = {};
        let lowerBodyActions = {};
        let mirroredUpperBodyActions = {};
        let mirroredLowerBodyActions = {};
        let currentUpperBodyAction = null;
        let currentLowerBodyAction = null;
        let currentUpperBodyAnimation = 'walk';
        let currentLowerBodyAnimation = 'walk';
        let balanceEnabled = false;
        let balanceValue = 0.5;
        let currentBalanceDirection = "center"; // left, center, right
        
        // Reference to hand bones for attaching bags
        let leftHand = null;
        let rightHand = null;
        
        // References to bags for attaching
        let allBags = {};
        let lightBags = [];
        let mediumBags = [];
        let heavyBags = [];

        // Selected bag and hand for pickup
        let selectedBag = null;
        let useLeftHand = false;

        // Currently attached bags
        let attachedBags = {
            leftHand: null,
            rightHand: null
        };

        // Bag offset positions based on weight
        const bagOffsets = {
            light: {
                position: new THREE.Vector3(0, -0.05, 0),
                rotation: new THREE.Euler(-Math.PI/2, 0, 0)
            },
            medium: {
                position: new THREE.Vector3(0, -0.1, 0),
                rotation: new THREE.Euler(-Math.PI/2, 0, 0)
            },
            heavy: {
                position: new THREE.Vector3(0, -0.15, 0),
                rotation: new THREE.Euler(-Math.PI/2, 0, 0)
            }
        };
        
        // Load models
        const loader = new THREE.GLTFLoader();
        let loadedCount = 0;
        let characterModel;
        
        models.forEach(model => {
            // Create label for this model
            const labelMesh = createLabel(model.name, {
                x: model.position[0],
                y: model.position[1],
                z: model.position[2]
            });
            
            loader.load(
                model.file,
                (gltf) => {
                    const modelObj = gltf.scene;
                    
                    // Apply scale and position
                    modelObj.scale.set(model.scale, model.scale, model.scale);
                    modelObj.position.set(...model.position);
                    
                    // Apply rotation if specified
                    if (model.rotationY !== undefined) {
                        modelObj.rotation.y = model.rotationY;
                    }
                    
                    // Enable shadows
                    modelObj.traverse(node => {
                        if (node.isMesh) {
                            node.castShadow = true;
                            node.receiveShadow = true;
                        }
                    });
                    
                    scene.add(modelObj);
                    
                    // Store references to bags
                    if (model.name === 'Ground Bag 1') groundBag1 = modelObj;
                    if (model.name === 'Ground Bag 2') groundBag2 = modelObj;
                    if (model.name === 'Car Bag 1') carBag1 = modelObj;
                    if (model.name === 'Car Bag 2') carBag2 = modelObj;
                    
                    // Set up character animations and bone references
                    if (model.name === 'Character') {
                        characterModel = modelObj;
                        
                        // Create animation mixer
                        mixer = new THREE.AnimationMixer(modelObj);
                        
                        // Store animations
                        animations = gltf.animations;
                        
                        // Find hand bones for attaching bags
                        modelObj.traverse(node => {
                            if (node.isBone) {
                                if (node.name === 'mixamorigLeftHand') {
                                    leftHand = node;
                                    console.log('Found left hand bone:', node.name);
                                }
                                if (node.name === 'mixamorigRightHand') {
                                    rightHand = node;
                                    console.log('Found right hand bone:', node.name);
                                }
                            }
                        });
                        
                        // Set up animation mixing
                        setupAnimationMixing(gltf.animations);
                    }
                    
                    // Store bag references
                    if (model.name.includes('Bag')) {
                        // Store by specific name
                        allBags[model.name] = {
                            mesh: modelObj,
                            weight: model.weight || 'medium',
                            originalParent: scene,
                            originalPosition: new THREE.Vector3(...model.position),
                            originalRotation: new THREE.Euler(0, model.rotationY || 0, 0),
                            originalScale: new THREE.Vector3(model.scale, model.scale, model.scale)
                        };
                        
                        // Also store by weight category
                        if (model.weight === 'light') {
                            lightBags.push(model.name);
                        } else if (model.weight === 'heavy') {
                            heavyBags.push(model.name);
                        } else {
                            mediumBags.push(model.name);
                        }
                        
                        console.log(`Added bag: ${model.name} with weight ${model.weight}`);
                    }
                    
                    // Update loaded count
                    loadedCount++;
                    document.getElementById('info').textContent = 
                        `Loaded ${loadedCount}/${models.length} models`;
                    
                    if (loadedCount === models.length) {
                        document.getElementById('info').textContent = 
                            `All models loaded - Use controls to test animations and balance system`;
                    }
                },
                (xhr) => {
                    console.log(`${model.name} ${Math.round(xhr.loaded / xhr.total * 100)}% loaded`);
                },
                (error) => {
                    console.error(`Error loading ${model.name}:`, error);
                    loadedCount++;
                    document.getElementById('info').textContent += 
                        `\nError loading ${model.name}`;
                }
            );
        });
        
        // Create a mirrored animation by flipping X values
        function createMirroredAnimation(originalClip, newName) {
            // Clone the original tracks
            const mirroredTracks = [];
            
            // Process each track in the original clip
            originalClip.tracks.forEach(track => {
                const trackName = track.name;
                const values = track.values.slice(); // Clone the values array
                
                // For position tracks, invert X values
                if (trackName.endsWith('.position')) {
                    // Position tracks have [x,y,z, x,y,z, ...] format
                    for (let i = 0; i < values.length; i += 3) {
                        values[i] = -values[i]; // Invert X position
                    }
                }
                
                // For quaternion tracks (rotations), invert appropriate components
                if (trackName.endsWith('.quaternion')) {
                    for (let i = 0; i < values.length; i += 4) {
                        values[i] = -values[i];      // Invert X component
                        values[i + 2] = -values[i + 2]; // Invert Z component
                    }
                }
                
                // Create a new track with mirrored values
                const mirroredTrack = new THREE.KeyframeTrack(
                    trackName,
                    track.times.slice(),
                    values
                );
                
                mirroredTracks.push(mirroredTrack);
            });
            
            // Create the mirrored animation clip
            return new THREE.AnimationClip(newName, originalClip.duration, mirroredTracks);
        }
        
        // Set up animation mixing system
        function setupAnimationMixing(clipsList) {
            // Create empty lists for animation dropdowns
            const upperSelect = document.getElementById('upperBodyAnim');
            const lowerSelect = document.getElementById('lowerBodyAnim');
            upperSelect.innerHTML = '';
            lowerSelect.innerHTML = '';
            
            // Upper body bone names to include
            const upperBodyBones = [
                'mixamorigSpine', 'mixamorigSpine1', 'mixamorigSpine2', 
                'mixamorigNeck', 'mixamorigHead', 'mixamorigHeadTop_End',
                'mixamorigLeftShoulder', 'mixamorigLeftArm', 'mixamorigLeftForeArm', 
                'mixamorigLeftHand', 'mixamorigLeftHandThumb1', 'mixamorigLeftHandThumb2', 
                'mixamorigLeftHandThumb3', 'mixamorigLeftHandThumb4', 'mixamorigLeftHandIndex1', 
                'mixamorigLeftHandIndex2', 'mixamorigLeftHandIndex3', 'mixamorigLeftHandIndex4',
                'mixamorigRightShoulder', 'mixamorigRightArm', 'mixamorigRightForeArm', 
                'mixamorigRightHand', 'mixamorigRightHandThumb1', 'mixamorigRightHandThumb2', 
                'mixamorigRightHandThumb3', 'mixamorigRightHandThumb4', 'mixamorigRightHandIndex1', 
                'mixamorigRightHandIndex2', 'mixamorigRightHandIndex3', 'mixamorigRightHandIndex4'
            ];
            
            // Lower body bone names to include
            const lowerBodyBones = [
                'mixamorigHips', 'mixamorigLeftUpLeg', 'mixamorigLeftLeg', 
                'mixamorigLeftFoot', 'mixamorigLeftToeBase', 'mixamorigLeftToe_End',
                'mixamorigRightUpLeg', 'mixamorigRightLeg', 'mixamorigRightFoot', 
                'mixamorigRightToeBase', 'mixamorigRightToe_End'
            ];
            
            // Process each animation
            clipsList.forEach(clip => {
                // Process the animation for upper body
                const upperBodyTracks = [];
                const lowerBodyTracks = [];
                
                // Split animation tracks into upper and lower body
                clip.tracks.forEach(track => {
                    const boneName = track.name.split('.')[0];
                    
                    if (upperBodyBones.includes(boneName)) {
                        upperBodyTracks.push(track);
                    } else if (lowerBodyBones.includes(boneName)) {
                        lowerBodyTracks.push(track);
                    }
                });
                
                // Create upper body clip
                const upperBodyClip = new THREE.AnimationClip(
                    clip.name + '_upper',
                    clip.duration,
                    upperBodyTracks
                );
                
                // Create lower body clip
                const lowerBodyClip = new THREE.AnimationClip(
                    clip.name + '_lower',
                    clip.duration,
                    lowerBodyTracks
                );
                
                // Create mirrored versions
                const mirroredUpperBodyClip = createMirroredAnimation(
                    upperBodyClip,
                    clip.name + '_upper_mirrored'
                );
                
                const mirroredLowerBodyClip = createMirroredAnimation(
                    lowerBodyClip,
                    clip.name + '_lower_mirrored'
                );
                
                // Store regular actions
                upperBodyActions[clip.name] = mixer.clipAction(upperBodyClip);
                lowerBodyActions[clip.name] = mixer.clipAction(lowerBodyClip);
                
                // Store mirrored actions
                mirroredUpperBodyActions[clip.name] = mixer.clipAction(mirroredUpperBodyClip);
                mirroredLowerBodyActions[clip.name] = mixer.clipAction(mirroredLowerBodyClip);
                
                // Add to dropdowns
                const upperOption = document.createElement('option');
                upperOption.value = clip.name;
                upperOption.text = clip.name;
                upperSelect.add(upperOption);
                
                const lowerOption = document.createElement('option');
                lowerOption.value = clip.name;
                lowerOption.text = clip.name;
                lowerSelect.add(lowerOption);
                
                // Set default selections
                if (clip.name === 'walk') {
                    upperSelect.value = clip.name;
                    lowerSelect.value = clip.name;
                }
            });
            
            // Initialize with default animations
            setUpperBodyAnimation('walk');
            setLowerBodyAnimation('walk');
            
            console.log(`Set up ${clipsList.length} animations for mixing`);
        }
        
        // Function to set upper body animation
        function setUpperBodyAnimation(name, mirrored = false) {
            let action;
            
            if (mirrored) {
                action = mirroredUpperBodyActions[name];
                if (!action) {
                    console.warn(`Mirrored upper body animation '${name}' not found`);
                    return;
                }
            } else {
                action = upperBodyActions[name];
                if (!action) {
                    console.warn(`Upper body animation '${name}' not found`);
                    return;
                }
            }
            
            // Fade out current animation
            if (currentUpperBodyAction) {
                currentUpperBodyAction.fadeOut(0.5);
            }
            
            // Play new animation
            action.reset();
            action.fadeIn(0.5);
            action.play();
            
            currentUpperBodyAction = action;
            currentUpperBodyAnimation = name;
            
            console.log(`Playing upper body animation: ${name}${mirrored ? ' (mirrored)' : ''}`);
        }
        
        // Function to set lower body animation
        function setLowerBodyAnimation(name, mirrored = false) {
            let action;
            
            if (mirrored) {
                action = mirroredLowerBodyActions[name];
                if (!action) {
                    console.warn(`Mirrored lower body animation '${name}' not found`);
                    return;
                }
            } else {
                action = lowerBodyActions[name];
                if (!action) {
                    console.warn(`Lower body animation '${name}' not found`);
                    return;
                }
            }
            
            // Fade out current animation
            if (currentLowerBodyAction) {
                currentLowerBodyAction.fadeOut(0.5);
            }
            
            // Play new animation
            action.reset();
            action.fadeIn(0.5);
            action.play();
            
            currentLowerBodyAction = action;
            currentLowerBodyAnimation = name;
            
            console.log(`Playing lower body animation: ${name}${mirrored ? ' (mirrored)' : ''}`);
        }
        
        // Function to update animations based on balance direction
        function updateAnimationsForBalance(direction) {
            if (direction === 'left') {
                // Use mirrored animations for left imbalance
                setLowerBodyAnimation('stumble_lowerbody', true);
                setUpperBodyAnimation(currentUpperBodyAnimation, true);
                console.log('Left imbalance - using mirrored animations');
            } else if (direction === 'right') {
                // Use regular animations for right imbalance
                setLowerBodyAnimation('stumble_lowerbody', false);
                setUpperBodyAnimation(currentUpperBodyAnimation, false);
                console.log('Right imbalance - using regular animations');
            } else {
                // Return to walking for balance
                setLowerBodyAnimation('walk', false);
                setUpperBodyAnimation(currentUpperBodyAnimation, false);
                console.log('Balanced - using regular walk animation for lower body');
            }
        }
        
        // Function to attach a bag to a specific hand
        function attachBagToHand(bagName, hand, isLeftHand = false) {
            if (!allBags[bagName] || !hand || !characterModel) {
                console.error("Cannot attach bag - missing references:", { 
                    bag: bagName ? true : false, 
                    hand: hand ? hand.name : false, 
                    character: characterModel ? true : false 
                });
                return;
            }
            
            const handName = isLeftHand ? 'leftHand' : 'rightHand';
            
            // Check if hand already has a bag
            if (attachedBags[handName]) {
                console.warn(`${isLeftHand ? 'Left' : 'Right'} hand already has a bag attached. Detach it first.`);
                return;
            }
            
            console.log(`Attaching ${bagName} to ${isLeftHand ? 'left' : 'right'} hand...`);
            
            const bagData = allBags[bagName];
            const bag = bagData.mesh;
            
            // Store original parent and transform if not already stored
            if (!bagData.originalParent) {
                bagData.originalParent = bag.parent;
                bagData.originalPosition = bag.position.clone();
                bagData.originalRotation = bag.rotation.clone();
                bagData.originalScale = bag.scale.clone();
            }
            
            // Remove from current parent
            bag.parent.remove(bag);
            
            // Add to hand
            hand.add(bag);
            
            // Apply position and rotation offsets based on weight
            const offsets = bagOffsets[bagData.weight];
            bag.position.copy(offsets.position);
            bag.rotation.copy(offsets.rotation);
            
            // If this is left hand, mirror the position
            if (isLeftHand) {
                bag.position.x = -bag.position.x;
                bag.rotation.z = -bag.rotation.z;
            }
            
            // Set attached bag data
            attachedBags[handName] = {
                name: bagName,
                mesh: bag,
                weight: bagData.weight
            };
            
            // Update UI
            updateBagStatusUI();
            
            console.log(`Bag ${bagName} attached successfully to ${isLeftHand ? 'left' : 'right'} hand`);
            
            // Switch to appropriate animation based on weight
            const animationPrefix = bagData.weight;
            setUpperBodyAnimation('carry_' + animationPrefix, currentBalanceDirection === 'left');
        }

        // Function to detach a bag from a specific hand
        function detachBag(isLeftHand = false) {
            const handName = isLeftHand ? 'leftHand' : 'rightHand';
            
            if (!attachedBags[handName]) {
                console.warn(`No bag attached to ${isLeftHand ? 'left' : 'right'} hand`);
                return;
            }
            
            console.log(`Detaching bag from ${isLeftHand ? 'left' : 'right'} hand...`);
            
            const bagName = attachedBags[handName].name;
            const bag = attachedBags[handName].mesh;
            const bagData = allBags[bagName];
            
            // Remove from hand
            bag.parent.remove(bag);
            
            // Add back to original parent
            bagData.originalParent.add(bag);
            
            // Restore original transform
            bag.position.copy(bagData.originalPosition);
            bag.rotation.copy(bagData.originalRotation);
            bag.scale.copy(bagData.originalScale);
            
            // Clear reference
            attachedBags[handName] = null;
            
            // Update UI
            updateBagStatusUI();
            
            console.log(`Bag detached successfully from ${isLeftHand ? 'left' : 'right'} hand`);
            
            // Check if both hands are empty, switch back to walk
            if (!attachedBags.leftHand && !attachedBags.rightHand) {
                setUpperBodyAnimation('walk', currentBalanceDirection === 'left');
            }
        }

        // Function to detach all bags
        function detachAllBags() {
            if (attachedBags.leftHand) {
                detachBag(true);
            }
            
            if (attachedBags.rightHand) {
                detachBag(false);
            }
            
            console.log("All bags detached");
        }

        // Function to update the UI showing which bags are carried
        function updateBagStatusUI() {
            const leftHandStatus = document.getElementById('leftHandStatus');
            const rightHandStatus = document.getElementById('rightHandStatus');
            
            if (attachedBags.leftHand) {
                const bagInfo = attachedBags.leftHand;
                leftHandStatus.textContent = `Left Hand: ${bagInfo.name} (${bagInfo.weight})`;
                leftHandStatus.style.color = getWeightColor(bagInfo.weight);
            } else {
                leftHandStatus.textContent = 'Left Hand: Empty';
                leftHandStatus.style.color = '#4CAF50';
            }
            
            if (attachedBags.rightHand) {
                const bagInfo = attachedBags.rightHand;
                rightHandStatus.textContent = `Right Hand: ${bagInfo.name} (${bagInfo.weight})`;
                rightHandStatus.style.color = getWeightColor(bagInfo.weight);
            } else {
                rightHandStatus.textContent = 'Right Hand: Empty';
                rightHandStatus.style.color = '#4CAF50';
            }
        }

        // Helper function to get color based on weight
        function getWeightColor(weight) {
            switch (weight) {
                case 'light': return '#4CAF50'; // green
                case 'medium': return '#FFC107'; // amber
                case 'heavy': return '#F44336'; // red
                default: return '#FFFFFF'; // white
            }
        }

        // Function to select a bag based on weight and location
        function selectBag(weight, isHigh) {
            let bagsList;
            
            // Get list based on weight
            if (weight === 'light') {
                bagsList = lightBags;
            } else if (weight === 'heavy') {
                bagsList = heavyBags;
            } else { // medium
                bagsList = mediumBags;
            }
            
            if (bagsList.length === 0) {
                console.warn(`No ${weight} bags available`);
                return null;
            }
            
            // Filter by location (high bags are on car, low bags are on ground)
            const filteredBags = bagsList.filter(bagName => {
                return isHigh ? bagName.includes('Car') : bagName.includes('Ground');
            });
            
            if (filteredBags.length === 0) {
                console.warn(`No ${isHigh ? 'high' : 'low'} ${weight} bags available`);
                return null;
            }
            
            // Find an unattached bag
            for (const bagName of filteredBags) {
                const isAttached = Object.values(attachedBags).some(bag => 
                    bag && bag.name === bagName);
                
                if (!isAttached) {
                    return bagName;
                }
            }
            
            console.warn(`All ${weight} bags are already attached`);
            return null;
        }

        // Function to perform pickup animation and attach bag
        function performPickup(weight, isHigh) {
            const bagName = selectBag(weight, isHigh);
            
            if (!bagName) {
                alert(`No available ${weight} bags to pick up from ${isHigh ? 'car' : 'ground'}`);
                return;
            }
            
            // Determine which hand to use
            const hand = useLeftHand ? leftHand : rightHand;
            const handName = useLeftHand ? 'left' : 'right';
            
            // Check if hand already has a bag
            if (attachedBags[`${handName}Hand`]) {
                alert(`${handName} hand already has a bag. Use the other hand or drop this bag first.`);
                return;
            }
            
            // Play pickup animation
            const animName = isHigh ? 'pickup_high' : 'pickup_low';
            setUpperBodyAnimation(animName, currentBalanceDirection === 'left');
            
            // Attach the bag after a short delay to simulate pickup
            setTimeout(() => {
                attachBagToHand(bagName, hand, useLeftHand);
            }, 1000); // 1 second delay
        }
        
        // Set up UI event listeners
        document.getElementById('upperBodyAnim').addEventListener('change', function() {
            // Update the animation and maintain the current mirroring if needed
            setUpperBodyAnimation(this.value, currentBalanceDirection === 'left');
        });
        
        document.getElementById('lowerBodyAnim').addEventListener('change', function() {
            // Only change if not in imbalance mode
            if (!balanceEnabled || currentBalanceDirection === 'center') {
                setLowerBodyAnimation(this.value);
            } else {
                alert("Can't change lower body animation while balance effect is active. Disable balance effect first.");
                this.value = currentLowerBodyAnimation;
            }
        });
        
        document.getElementById('pickupLowBtn').addEventListener('click', function() {
            setUpperBodyAnimation('pickup_low', currentBalanceDirection === 'left');
        });
        
        document.getElementById('pickupHighBtn').addEventListener('click', function() {
            setUpperBodyAnimation('pickup_high', currentBalanceDirection === 'left');
        });
        
        document.getElementById('attachBagBtn').addEventListener('click', function() {
            if (rightHand && groundBag1) {
                attachBagToHand(groundBag1, rightHand);
            } else {
                const message = "Cannot attach bag. Debug info: " + 
                    "Right hand found: " + (rightHand ? "Yes" : "No") + ", " +
                    "Ground bag found: " + (groundBag1 ? "Yes" : "No");
                console.error(message);
                alert(message);
            }
        });
        
        document.getElementById('detachBagBtn').addEventListener('click', function() {
            detachBag();
        });
        
        document.getElementById('balanceSlider').addEventListener('input', function() {
            balanceValue = this.value / 100;
            updateBalanceSystem(balanceValue);
        });
        
        document.getElementById('toggleBalance').addEventListener('click', function() {
            balanceEnabled = !balanceEnabled;
            this.textContent = balanceEnabled ? 
                'Disable Balance Effect' : 'Enable Balance Effect';
            
            // Apply current balance state immediately when toggled
            updateBalanceSystem(balanceValue);
        });
        
        document.getElementById('gameView').addEventListener('click', () => {
            camera.position.set(-17, 2, -25);
            controls.target.set(-15, 1, -20);
            controls.update();
        });
        
        document.getElementById('resetView').addEventListener('click', () => {
            camera.position.set(0, 20, 30);
            controls.target.set(0, 0, 0);
            controls.update();
        });
        
        // Animation loop
        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            
            const delta = clock.getDelta();
            
            // Update character animations
            if (mixer) mixer.update(delta);
            
            // Update label orientations
            scene.children.forEach(child => {
                if (child.material && child.material.map && 
                    child.material.map.isCanvasTexture) {
                    child.lookAt(camera.position);
                }
            });
            
            renderer.render(scene, camera);
        }
        animate();
        
        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Set up hand selection buttons
        document.getElementById('attachLeftHandBtn').addEventListener('click', function() {
            useLeftHand = true;
            this.style.backgroundColor = '#4CAF50';
            document.getElementById('attachRightHandBtn').style.backgroundColor = '';
            console.log('Using left hand');
        });

        document.getElementById('attachRightHandBtn').addEventListener('click', function() {
            useLeftHand = false;
            this.style.backgroundColor = '#4CAF50';
            document.getElementById('attachLeftHandBtn').style.backgroundColor = '';
            console.log('Using right hand');
        });

        document.getElementById('detachAllBagsBtn').addEventListener('click', function() {
            detachAllBags();
        });

        // Set up low pickup buttons
        document.getElementById('pickupLowLightBtn').addEventListener('click', function() {
            performPickup('light', false);
        });

        document.getElementById('pickupLowMediumBtn').addEventListener('click', function() {
            performPickup('medium', false);
        });

        document.getElementById('pickupLowHeavyBtn').addEventListener('click', function() {
            performPickup('heavy', false);
        });

        // Set up high pickup buttons
        document.getElementById('pickupHighLightBtn').addEventListener('click', function() {
            performPickup('light', true);
        });

        document.getElementById('pickupHighMediumBtn').addEventListener('click', function() {
            performPickup('medium', true);
        });

        document.getElementById('pickupHighHeavyBtn').addEventListener('click', function() {
            performPickup('heavy', true);
        });

        // Select right hand by default
        document.getElementById('attachRightHandBtn').click();
    </script>
</body>
</html> 