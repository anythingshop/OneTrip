<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>One Trip</title>
    <style>
        body { 
            margin: 0; 
            padding: 0; 
            overflow: hidden; 
            background: #222;
            font-family: Arial, sans-serif;
        }
        #game-container { 
            width: 100%; 
            height: 100vh; 
        }
        #ui-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        #loading-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: white;
            pointer-events: auto;
        }
        #loading-bar-container {
            width: 50%;
            height: 30px;
            background: #333;
            border-radius: 15px;
            margin-top: 20px;
            overflow: hidden;
        }
        #loading-bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #4CAF50, #8BC34A);
            transition: width 0.3s;
        }
        #balance-meter {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            height: 25px;
            background: rgba(0,0,0,0.5);
            border-radius: 12px;
            overflow: hidden;
            display: none;
        }
        #balance-indicator {
            position: absolute;
            top: 0;
            left: 50%;
            width: 10px;
            height: 100%;
            background: white;
            transform: translateX(-50%);
            transition: left 0.1s;
        }
        #balance-zone {
            position: absolute;
            top: 0;
            left: 40%;
            width: 20%;
            height: 100%;
            background: rgba(76, 175, 80, 0.3);
        }
        #item-counter {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.5);
            color: white;
            padding: 10px 15px;
            border-radius: 5px;
            display: none;
        }
        #controls {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.5);
            color: white;
            padding: 10px 15px;
            border-radius: 5px;
            pointer-events: none;
        }
        .win-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 32px;
            z-index: 1000;
            pointer-events: auto;
        }
        .win-screen button {
            padding: 10px 20px;
            margin-top: 20px;
            font-size: 18px;
            cursor: pointer;
            background: #4CAF50;
            border: none;
            border-radius: 5px;
            color: white;
        }
    </style>
</head>
<body>
    <div id="game-container"></div>
    
    <div id="ui-container">
        <div id="loading-screen">
            <h1>One Trip</h1>
            <p>Loading assets...</p>
            <div id="loading-bar-container">
                <div id="loading-bar"></div>
            </div>
        </div>
        
        <div id="balance-meter">
            <div id="balance-zone"></div>
            <div id="balance-indicator"></div>
        </div>
        
        <div id="item-counter">Bags: 0/5</div>
        
        <div id="controls">
            <p>WASD: Move</p>
            <p>SHIFT: Run</p>
            <p>E: Pickup bag</p>
            <p>Q/E: Balance Left/Right</p>
        </div>
    </div>

    <!-- Three.js Library -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.147.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.147.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.147.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.147.0/examples/js/loaders/DRACOLoader.js"></script>

    <script>
        class OneTripGame {
            constructor() {
                // Asset paths - using simple relative paths since files are in the same directory
                this.assets = {
                    character: './onetrip_maincharacter.glb',
                    bag1: './newbag.glb',
                    bag2: './bag2.glb',
                    car: './car.glb',
                    house: './house.glb'
                };
                
                // Game state
                this.state = {
                    isLoading: true,
                    assetsLoaded: 0,
                    totalAssets: Object.keys(this.assets).length,
                    isPlaying: false,
                    bagsCarried: 0,
                    maxBags: 5,
                    balance: 0.5, // 0 = fall left, 1 = fall right, 0.5 = balanced
                    balanceStability: 1.0, // 0 = very unstable, 1 = stable
                    gameOver: false,
                    isStumbling: false
                };
                
                // Animation states
                this.animations = {
                    current: 'tpose',
                    mixer: null,
                    clips: {},
                    actions: {}
                };
                
                // Bag attachment points
                this.attachPoints = [];
                
                // Available bags
                this.bags = [];
                this.availableBags = [];
                
                // Timekeeping
                this.clock = new THREE.Clock();
                
                // Win flag
                this.winScreenShown = false;
                
                // Initialize game
                this.init();
                
                // Add asset loading timeout for fallback
                setTimeout(() => {
                    if (this.state.isLoading) {
                        console.log("Assets taking too long to load - creating placeholders");
                        this.handleMissingAssets();
                    }
                }, 10000);
            }
            
            init() {
                // Check asset URLs first
                this.checkAssetUrls();
                
                // Set up scene
                this.setupScene();
                
                // Set up input
                this.setupInput();
                
                // Add debug console
                this.addDebugConsole();
                
                // Load assets
                this.loadAssets();
                
                // Start game loop
                this.animate();
            }
            
            setupScene() {
                // Create scene
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x87CEEB); // Sky blue
                
                // Create camera
                this.camera = new THREE.PerspectiveCamera(
                    75, 
                    window.innerWidth / window.innerHeight, 
                    0.1, 
                    1000
                );
                this.camera.position.set(0, 2, 5);
                
                // Create renderer
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(window.devicePixelRatio);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                document.getElementById('game-container').appendChild(this.renderer.domElement);
                
                // Add lights
                this.addLights();
                
                // Add ground
                this.addGround();
                
                // Handle window resize
                window.addEventListener('resize', () => this.onWindowResize());
                
                // Add temporary controls for development
                this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
                this.controls.target.set(0, 1, 0);
                this.controls.update();
            }
            
            addLights() {
                // Main directional light (sun)
                this.sunLight = new THREE.DirectionalLight(0xFFFFFF, 1);
                this.sunLight.position.set(10, 10, 10);
                this.sunLight.castShadow = true;
                this.sunLight.shadow.mapSize.width = 2048;
                this.sunLight.shadow.mapSize.height = 2048;
                this.sunLight.shadow.camera.near = 0.5;
                this.sunLight.shadow.camera.far = 50;
                this.sunLight.shadow.camera.left = -20;
                this.sunLight.shadow.camera.right = 20;
                this.sunLight.shadow.camera.top = 20;
                this.sunLight.shadow.camera.bottom = -20;
                this.scene.add(this.sunLight);
                
                // Ambient light
                this.ambientLight = new THREE.AmbientLight(0x404040, 0.5);
                this.scene.add(this.ambientLight);
                
                // Hemisphere light for natural outdoor lighting
                this.hemiLight = new THREE.HemisphereLight(0xB1E1FF, 0x444444, 0.6);
                this.scene.add(this.hemiLight);
            }
            
            addGround() {
                // Create ground plane
                const groundGeometry = new THREE.PlaneGeometry(100, 100);
                const groundMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x7CFC00, 
                    roughness: 0.8, 
                    metalness: 0.1 
                });
                this.ground = new THREE.Mesh(groundGeometry, groundMaterial);
                this.ground.rotation.x = -Math.PI / 2;
                this.ground.receiveShadow = true;
                this.scene.add(this.ground);
            }
            
            onWindowResize() {
                // Update camera aspect ratio
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                
                // Update renderer size
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }
            
            setupInput() {
                // Key states
                this.keys = {};
                
                // Add event listeners
                window.addEventListener('keydown', (e) => {
                    this.keys[e.code] = true;
                });
                
                window.addEventListener('keyup', (e) => {
                    this.keys[e.code] = false;
                });
            }
            
            loadAssets() {
                // Set up loaders
                this.gltfLoader = new THREE.GLTFLoader();
                
                // Optional: Set up Draco loader for compressed models
                const dracoLoader = new THREE.DRACOLoader();
                dracoLoader.setDecoderPath('https://www.gstatic.com/draco/v1/decoders/');
                this.gltfLoader.setDRACOLoader(dracoLoader);
                
                // Load character
                this.loadCharacter();
                
                // Load other assets
                this.loadCar();
                this.loadHouse();
                this.loadBags();
            }
            
            loadCharacter() {
                this.gltfLoader.load(
                    this.assets.character,
                    (gltf) => {
                        // Add character to scene
                        this.character = gltf.scene;
                        this.character.scale.set(1, 1, 1);
                        this.character.position.set(-3, 0, 0);
                        this.character.castShadow = true;
                        this.character.receiveShadow = true;
                        this.scene.add(this.character);
                        
                        // Enable shadows for all meshes
                        this.character.traverse((node) => {
                            if (node.isMesh) {
                                node.castShadow = true;
                                node.receiveShadow = true;
                            }
                        });
                        
                        // Set up animations
                        this.setupAnimations(gltf);
                        
                        // Update loading progress
                        this.updateLoadingProgress();
                    },
                    (xhr) => {
                        console.log(`Character ${(xhr.loaded / xhr.total) * 100}% loaded`);
                    },
                    (error) => {
                        console.error('Error loading character:', error);
                        // Add a user-friendly error message
                        document.getElementById('loading-screen').innerHTML = `
                            <h1>Error Loading Game</h1>
                            <p>Failed to load character model. Please refresh the page or check your connection.</p>
                        `;
                    }
                );
            }
            
            setupAnimations(gltf) {
                // Create animation mixer
                this.animations.mixer = new THREE.AnimationMixer(this.character);
                
                // Store all animation clips
                gltf.animations.forEach(clip => {
                    this.animations.clips[clip.name] = clip;
                    
                    // Create action for each clip
                    const action = this.animations.mixer.clipAction(clip);
                    this.animations.actions[clip.name] = action;
                    
                    console.log(`Added animation: ${clip.name}`);
                });
                
                // Check for required animations
                const requiredAnimations = ['tpose', 'walk', 'run', 'stumble_fall'];
                requiredAnimations.forEach(anim => {
                    if (!this.animations.actions[anim]) {
                        console.warn(`Required animation missing: ${anim}`);
                    }
                });
                
                // Play initial animation
                this.playAnimation('tpose');
            }
            
            playAnimation(name, fadeTime = 0.5) {
                if (!this.animations.actions[name]) {
                    console.warn(`Animation ${name} not found, using fallback`);
                    // Use tpose as fallback if requested animation doesn't exist
                    if (name.includes('carry')) {
                        name = this.animations.actions['carry_stand_medium'] ? 
                              'carry_stand_medium' : 'tpose';
                    } else {
                        name = 'tpose';
                    }
                    
                    // If even the fallback doesn't exist, return
                    if (!this.animations.actions[name]) return;
                }
                
                // Skip if already playing this animation
                if (this.animations.current === name) return;
                
                // Get current and new actions
                const current = this.animations.actions[this.animations.current];
                const next = this.animations.actions[name];
                
                // Fade out current animation
                if (current) {
                    current.fadeOut(fadeTime);
                }
                
                // Fade in new animation
                next.reset();
                next.fadeIn(fadeTime);
                next.play();
                
                // Update current animation
                this.animations.current = name;
            }
            
            loadCar() {
                this.gltfLoader.load(
                    this.assets.car,
                    (gltf) => {
                        // Add car to scene
                        this.car = gltf.scene;
                        this.car.scale.set(1, 1, 1);
                        this.car.position.set(-5, 0, 0); // Position to the left
                        this.car.rotation.y = Math.PI / 2; // Rotate to face right
                        this.car.castShadow = true;
                        this.car.receiveShadow = true;
                        this.scene.add(this.car);
                        
                        // Enable shadows for all meshes
                        this.car.traverse((node) => {
                            if (node.isMesh) {
                                node.castShadow = true;
                                node.receiveShadow = true;
                            }
                        });
                        
                        // Update loading progress
                        this.updateLoadingProgress();
                    },
                    (xhr) => {
                        console.log(`Car ${(xhr.loaded / xhr.total) * 100}% loaded`);
                    },
                    (error) => {
                        console.error('Error loading car:', error);
                    }
                );
            }
            
            loadHouse() {
                this.gltfLoader.load(
                    this.assets.house,
                    (gltf) => {
                        // Add house to scene
                        this.house = gltf.scene;
                        this.house.scale.set(1, 1, 1);
                        this.house.position.set(5, 0, 0); // Position to the right
                        this.house.castShadow = true;
                        this.house.receiveShadow = true;
                        this.scene.add(this.house);
                        
                        // Enable shadows for all meshes
                        this.house.traverse((node) => {
                            if (node.isMesh) {
                                node.castShadow = true;
                                node.receiveShadow = true;
                            }
                        });
                        
                        // Update loading progress
                        this.updateLoadingProgress();
                    },
                    (xhr) => {
                        console.log(`House ${(xhr.loaded / xhr.total) * 100}% loaded`);
                    },
                    (error) => {
                        console.error('Error loading house:', error);
                    }
                );
            }
            
            loadBags() {
                // Load bag1
                this.gltfLoader.load(
                    this.assets.bag1,
                    (gltf) => {
                        // Store template for creating instances
                        this.bag1Template = gltf.scene;
                        
                        // Update loading progress
                        this.updateLoadingProgress();
                        
                        // Check if both bag types are loaded
                        if (this.bag1Template && this.bag2Template) {
                            this.createBagsOnCar();
                        }
                    },
                    (xhr) => {
                        console.log(`Bag1 ${(xhr.loaded / xhr.total) * 100}% loaded`);
                    },
                    (error) => {
                        console.error('Error loading bag1:', error);
                    }
                );
                
                // Load bag2
                this.gltfLoader.load(
                    this.assets.bag2,
                    (gltf) => {
                        // Store template for creating instances
                        this.bag2Template = gltf.scene;
                        
                        // Update loading progress
                        this.updateLoadingProgress();
                        
                        // Check if both bag types are loaded
                        if (this.bag1Template && this.bag2Template) {
                            this.createBagsOnCar();
                        }
                    },
                    (xhr) => {
                        console.log(`Bag2 ${(xhr.loaded / xhr.total) * 100}% loaded`);
                    },
                    (error) => {
                        console.error('Error loading bag2:', error);
                    }
                );
            }
            
            updateLoadingProgress() {
                // Increment assets loaded
                this.state.assetsLoaded++;
                
                // Calculate progress
                const progress = this.state.assetsLoaded / this.state.totalAssets;
                
                // Update loading bar
                document.getElementById('loading-bar').style.width = `${progress * 100}%`;
                
                // Check if all assets are loaded
                if (this.state.assetsLoaded >= this.state.totalAssets) {
                    this.onAssetsLoaded();
                }
            }
            
            onAssetsLoaded() {
                // All assets loaded, start game
                setTimeout(() => {
                    // Hide loading screen
                    document.getElementById('loading-screen').style.display = 'none';
                    
                    // Show game UI
                    document.getElementById('balance-meter').style.display = 'block';
                    document.getElementById('item-counter').style.display = 'block';
                    
                    // Set game state to playing
                    this.state.isLoading = false;
                    this.state.isPlaying = true;
                    
                    console.log('Game started!');
                }, 1000);
            }
            
            createBagsOnCar() {
                if (!this.bag1Template || !this.bag2Template || !this.car) return;
                
                this.bags = [];
                this.availableBags = [];
                
                // Create 5 bags - alternating types
                const bagPositions = [
                    { x: -5.2, y: 1.2, z: 0.2, type: 'bag1', onCar: true },
                    { x: -4.8, y: 1.2, z: -0.2, type: 'bag2', onCar: true },
                    { x: -5.0, y: 1.2, z: 0.0, type: 'bag1', onCar: true },
                    { x: -5.3, y: 0.15, z: 0.5, type: 'bag2', onCar: false },
                    { x: -4.7, y: 0.15, z: -0.5, type: 'bag1', onCar: false }
                ];
                
                bagPositions.forEach((pos, index) => {
                    // Choose template based on type
                    const template = pos.type === 'bag1' ? this.bag1Template : this.bag2Template;
                    
                    // Create bag
                    const bag = template.clone();
                    bag.position.set(pos.x, pos.y, pos.z);
                    bag.scale.set(0.5, 0.5, 0.5); // Adjust scale as needed
                    bag.castShadow = true;
                    bag.receiveShadow = true;
                    
                    // Add metadata
                    bag.userData = {
                        id: index,
                        isCarried: false,
                        isOnCar: pos.onCar,
                        type: pos.type
                    };
                    
                    // Add to scene
                    this.scene.add(bag);
                    
                    // Store reference
                    this.bags.push(bag);
                    this.availableBags.push(bag);
                });
                
                console.log(`Created ${this.bags.length} bags`);
            }
            
            handleInput(deltaTime) {
                // Movement keys
                const moveForward = this.keys['KeyW'] || false;
                const moveBackward = this.keys['KeyS'] || false;
                const moveLeft = this.keys['KeyA'] || false;
                const moveRight = this.keys['KeyD'] || false;
                
                // Action keys
                const isRunning = this.keys['ShiftLeft'] || false;
                const isPickingUp = this.keys['KeyE'] || false;
                
                // Skip if character isn't loaded
                if (!this.character) return;
                
                // Calculate movement direction
                let moveX = 0;
                let moveZ = 0;
                
                if (moveForward) moveZ -= 1;
                if (moveBackward) moveZ += 1;
                if (moveLeft) moveX -= 1;
                if (moveRight) moveX += 1;
                
                // Normalize for diagonal movement
                const length = Math.sqrt(moveX * moveX + moveZ * moveZ);
                if (length > 0) {
                    moveX /= length;
                    moveZ /= length;
                }
                
                // Calculate speed based on running and bag weight
                let baseSpeed = isRunning ? 5 : 3;
                
                // Reduce speed based on number of bags carried
                const bagWeight = this.state.bagsCarried * 0.15;
                const speedFactor = Math.max(0.3, 1 - bagWeight);
                const effectiveSpeed = baseSpeed * speedFactor;
                
                // Apply movement
                this.character.position.x += moveX * effectiveSpeed * deltaTime;
                this.character.position.z += moveZ * effectiveSpeed * deltaTime;
                
                // Rotate character to face movement direction
                if (length > 0) {
                    const targetRotation = Math.atan2(moveX, moveZ);
                    this.character.rotation.y = targetRotation;
                    
                    // Determine animation
                    if (this.state.bagsCarried > 0) {
                        // Carrying bags
                        const loadWeight = this.state.bagsCarried > 2 ? 'heavy' : 'medium';
                        const moveSpeed = isRunning ? 'run' : 'walk';
                        this.playAnimation(`carry_${moveSpeed}_${loadWeight}`);
                    } else {
                        // Not carrying anything
                        this.playAnimation(isRunning ? 'run' : 'walk');
                    }
                } else {
                    // Character is standing still
                    if (this.state.bagsCarried > 0) {
                        const loadWeight = this.state.bagsCarried > 2 ? 'heavy' : 'medium';
                        this.playAnimation(`carry_stand_${loadWeight}`);
                    } else {
                        this.playAnimation('tpose');
                    }
                }
                
                // Handle pickup
                if (isPickingUp && !this.state.gameOver) {
                    this.tryPickupBag();
                }
            }
            
            tryPickupBag() {
                // Skip if already carrying max bags or during animation
                if (this.state.bagsCarried >= this.state.maxBags || 
                    this.animations.current.includes('pickup')) return;
                
                // Find closest bag
                let closestBag = null;
                let closestDistance = 2; // Maximum pickup distance
                
                this.availableBags.forEach(bag => {
                    const distance = this.character.position.distanceTo(bag.position);
                    
                    if (distance < closestDistance) {
                        closestDistance = distance;
                        closestBag = bag;
                    }
                });
                
                if (closestBag) {
                    // Determine if bag is on car or ground
                    const pickupType = closestBag.userData.isOnCar ? 'pickup_high' : 'pickup_low';
                    
                    // Play pickup animation
                    this.playAnimation(pickupType, 0.3);
                    
                    // Set timeout to coincide with animation
                    setTimeout(() => {
                        // Remove from available bags
                        this.availableBags = this.availableBags.filter(bag => bag !== closestBag);
                        
                        // Hide the original bag
                        this.scene.remove(closestBag);
                        
                        // Increase carried bags counter
                        this.state.bagsCarried++;
                        
                        // Update UI
                        document.getElementById('item-counter').textContent = `Bags: ${this.state.bagsCarried}/${this.state.maxBags}`;
                        
                        // Create bag attached to character
                        this.attachBagToCharacter(closestBag.userData.type);
                        
                        // Transition to carry animation
                        const loadWeight = this.state.bagsCarried > 2 ? 'heavy' : 'medium';
                        this.playAnimation(`carry_stand_${loadWeight}`);
                    }, 1000); // Timing should match animation
                }
            }
            
            attachBagToCharacter(bagType) {
                if (!this.character) return;
                
                // Create attachment points if they don't exist
                if (this.attachPoints.length === 0) {
                    // Define attachment points based on number of bags
                    const points = [
                        { x: 0, y: 1.2, z: 0.2 },  // First bag - center
                        { x: 0.2, y: 1.2, z: 0.2 }, // Second bag - right side
                        { x: -0.2, y: 1.2, z: 0.2 }, // Third bag - left side
                        { x: 0, y: 1.4, z: 0.2 },  // Fourth bag - top center
                        { x: 0.1, y: 1.4, z: 0.3 }  // Fifth bag - top right
                    ];
                    
                    points.forEach((point, index) => {
                        const attachPoint = new THREE.Object3D();
                        attachPoint.position.set(point.x, point.y, point.z);
                        this.character.add(attachPoint);
                        this.attachPoints.push(attachPoint);
                    });
                }
                
                // Choose template based on type
                const template = bagType === 'bag1' ? this.bag1Template : this.bag2Template;
                
                // Create new bag instance
                const bag = template.clone();
                bag.scale.set(0.5, 0.5, 0.5);
                
                // Attach to appropriate point
                const attachIndex = this.state.bagsCarried - 1;
                if (this.attachPoints[attachIndex]) {
                    this.attachPoints[attachIndex].add(bag);
                }
                
                // Adjust balance difficulty based on bag position
                if (attachIndex > 1) {
                    // Bags beyond the first two make balance harder
                    this.state.balanceStability *= 0.8;
                }
            }
            
            dropAllBags() {
                // Skip if no bags
                if (this.state.bagsCarried === 0) return;
                
                // Process each attachment point
                this.attachPoints.forEach(point => {
                    // Process all children of this point (should be bags)
                    while (point.children.length > 0) {
                        const bag = point.children[0];
                        
                        // Get world position
                        const worldPos = new THREE.Vector3();
                        bag.getWorldPosition(worldPos);
                        
                        // Remove from attachment
                        point.remove(bag);
                        
                        // Create new bag at world position
                        const newBag = bag.clone();
                        newBag.position.copy(worldPos);
                        
                        // Add some randomness to the drop
                        newBag.position.x += (Math.random() - 0.5) * 2;
                        newBag.position.z += (Math.random() - 0.5) * 2;
                        newBag.position.y = 0.15; // Place on ground
                        
                        // Random rotation
                        newBag.rotation.y = Math.random() * Math.PI * 2;
                        
                        // Add back to scene
                        this.scene.add(newBag);
                        
                        // Add to available bags
                        newBag.userData = {
                            id: this.bags.length,
                            isCarried: false,
                            isOnCar: false,
                            type: Math.random() > 0.5 ? 'bag1' : 'bag2'
                        };
                        
                        this.bags.push(newBag);
                        this.availableBags.push(newBag);
                    }
                });
                
                // Reset state
                this.state.bagsCarried = 0;
                this.state.balanceStability = 1.0;
                
                // Update UI
                document.getElementById('item-counter').textContent = `Bags: ${this.state.bagsCarried}/${this.state.maxBags}`;
            }
            
            updateBalance(deltaTime) {
                // Skip if not carrying bags
                if (this.state.bagsCarried === 0) {
                    // Reset indicator position
                    document.getElementById('balance-indicator').style.left = '50%';
                    // Reset character rotation
                    if (this.character) this.character.rotation.z = 0;
                    return;
                }
                
                // Skip during pickup animation
                if (this.animations.current.includes('pickup')) return;
                
                // Balance difficulty scales with number of bags and stability
                const balanceDifficulty = this.state.bagsCarried * 0.1 / this.state.balanceStability;
                
                // Random wobble based on difficulty
                const randomWobble = (Math.random() - 0.5) * balanceDifficulty;
                
                // Player input for balance
                const balanceLeft = this.keys['KeyQ'] || false;
                const balanceRight = this.keys['KeyE'] || false;
                
                let balanceInput = 0;
                if (balanceLeft) balanceInput -= 0.02;
                if (balanceRight) balanceInput += 0.02;
                
                // Update balance value
                this.state.balance += randomWobble * deltaTime * 2;
                this.state.balance += balanceInput;
                
                // Clamp balance between 0 and 1
                this.state.balance = Math.max(0, Math.min(1, this.state.balance));
                
                // Update UI
                const indicator = document.getElementById('balance-indicator');
                indicator.style.left = `${this.state.balance * 100}%`;
                
                // Apply tilting effect to character
                if (this.character) {
                    // Tilt based on balance (convert 0-1 to -0.3 to 0.3 radians)
                    const tiltAmount = (this.state.balance - 0.5) * 0.6;
                    this.character.rotation.z = tiltAmount;
                    
                    // Blend in stumble animation for lower body when near edge
                    if ((this.state.balance < 0.3 || this.state.balance > 0.7) && 
                        this.animations.actions['stumble_lowerbody']) {
                        
                        if (!this.state.isStumbling && !this.animations.current.includes('pickup') && 
                            !this.state.gameOver) {
                            // Mix stumble for lower body with current carry animation
                            const stumbleAction = this.animations.actions['stumble_lowerbody'];
                            
                            stumbleAction.reset();
                            stumbleAction.setEffectiveWeight(0.5);
                            stumbleAction.play();
                            
                            this.state.isStumbling = true;
                            console.log("Starting to stumble");
                        }
                    } else if (this.state.isStumbling) {
                        // Return to normal animation
                        const stumbleAction = this.animations.actions['stumble_lowerbody'];
                        if (stumbleAction) {
                            stumbleAction.stop();
                            this.state.isStumbling = false;
                            console.log("Recovering from stumble");
                        }
                    }
                    
                    // Check if balance is completely lost
                    if ((this.state.balance < 0.1 || this.state.balance > 0.9) && !this.state.gameOver) {
                        this.loseBalance();
                    }
                }
            }
            
            loseBalance() {
                // Skip if already triggered
                if (this.state.gameOver) return;
                
                console.log("Lost balance!");
                
                // Play stumble animation
                this.playAnimation('stumble_fall', 0.3);
                
                // Drop all bags
                setTimeout(() => {
                    this.dropAllBags();
                }, 500);
                
                // Game over state
                this.state.gameOver = true;
                
                // Reset after delay
                setTimeout(() => {
                    this.state.gameOver = false;
                    this.state.balance = 0.5;
                    this.state.isStumbling = false;
                    
                    // Return to idle animation
                    this.playAnimation('tpose');
                    
                    console.log("Reset after fall");
                }, 3000);
            }
            
            updateCamera() {
                // Skip if character isn't loaded
                if (!this.character) return;
                
                // Set camera to follow behind character
                const targetPos = new THREE.Vector3();
                this.character.getWorldPosition(targetPos);
                
                // Get character's forward direction
                const forward = new THREE.Vector3(0, 0, -1);
                forward.applyQuaternion(this.character.quaternion);
                
                // Position camera behind character
                const cameraOffset = new THREE.Vector3()
                    .copy(forward)
                    .multiplyScalar(-5) // Distance behind
                    .add(new THREE.Vector3(0, 2, 0)); // Height offset
                
                const cameraTargetPos = new THREE.Vector3()
                    .copy(targetPos)
                    .add(cameraOffset);
                
                // Check if the calculated position is valid
                if (isNaN(cameraTargetPos.x) || isNaN(cameraTargetPos.y) || isNaN(cameraTargetPos.z)) {
                    console.error('Invalid camera position calculated');
                    return;
                }
                
                // Smoothly move camera
                this.camera.position.lerp(cameraTargetPos, 0.05);
                
                // Look at character
                this.controls.target.copy(targetPos);
                this.controls.update();
            }
            
            // Check if player reached house with all bags
            checkWinCondition() {
                if (!this.character || !this.house || this.state.gameOver) return;
                
                // Get positions
                const characterPos = new THREE.Vector3();
                this.character.getWorldPosition(characterPos);
                
                const housePos = new THREE.Vector3();
                this.house.getWorldPosition(housePos);
                
                // Calculate distance to house
                const distanceToHouse = characterPos.distanceTo(housePos);
                
                // Check win condition
                if (distanceToHouse < 5 && this.state.bagsCarried === this.state.maxBags) {
                    // Player won!
                    this.showWinScreen();
                }
            }
            
            showWinScreen() {
                if (this.winScreenShown) return;
                this.winScreenShown = true;
                
                console.log("Win condition met!");
                
                // Create win screen
                const winScreen = document.createElement('div');
                winScreen.className = 'win-screen';
                winScreen.innerHTML = `
                    <h1>You made it in ONE TRIP!</h1>
                    <p>You successfully carried all ${this.state.maxBags} bags to the house.</p>
                    <button id="restart-button">Play Again</button>
                `;
                
                // Add to document
                document.body.appendChild(winScreen);
                
                // Add restart event
                setTimeout(() => {
                    document.getElementById('restart-button').addEventListener('click', () => {
                        document.body.removeChild(winScreen);
                        this.resetGame();
                    });
                }, 100);
                
                // Play celebration animation
                this.playAnimation('tpose');
            }
            
            resetGame() {
                // Reset win flag
                this.winScreenShown = false;
                
                // Reset character position
                if (this.character) {
                    this.character.position.set(-3, 0, 0);
                }
                
                // Reset bags
                this.dropAllBags();
                
                // Recreate bags
                this.bags.forEach(bag => this.scene.remove(bag));
                this.bags = [];
                this.availableBags = [];
                this.createBagsOnCar();
                
                // Reset game state
                this.state.bagsCarried = 0;
                this.state.balance = 0.5;
                this.state.balanceStability = 1.0;
                this.state.gameOver = false;
                this.state.isStumbling = false;
                
                // Reset UI
                document.getElementById('item-counter').textContent = `Bags: ${this.state.bagsCarried}/${this.state.maxBags}`;
            }
            
            update(deltaTime) {
                // Skip if game isn't active
                if (!this.state.isPlaying) return;
                
                // Update animations
                if (this.animations.mixer) {
                    this.animations.mixer.update(deltaTime);
                }
                
                // Handle input (skip during game over)
                if (!this.state.gameOver) {
                    this.handleInput(deltaTime);
                }
                
                // Update balance
                this.updateBalance(deltaTime);
                
                // Update camera
                this.updateCamera();
                
                // Check win condition
                this.checkWinCondition();
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                
                // Calculate delta time
                const deltaTime = this.clock.getDelta();
                
                // Update game
                this.update(deltaTime);
                
                // Render scene
                this.renderer.render(this.scene, this.camera);
            }
            
            addDebugConsole() {
                // Create debug console container
                const debugContainer = document.createElement('div');
                debugContainer.style.position = 'absolute';
                debugContainer.style.bottom = '10px';
                debugContainer.style.right = '10px';
                debugContainer.style.backgroundColor = 'rgba(0,0,0,0.7)';
                debugContainer.style.color = 'white';
                debugContainer.style.padding = '10px';
                debugContainer.style.borderRadius = '5px';
                debugContainer.style.maxHeight = '200px';
                debugContainer.style.overflow = 'auto';
                debugContainer.style.maxWidth = '300px';
                debugContainer.style.fontSize = '12px';
                debugContainer.id = 'debug-console';
                document.body.appendChild(debugContainer);
                
                // Override console.log and console.error
                const originalLog = console.log;
                const originalError = console.error;
                
                console.log = function() {
                    originalLog.apply(console, arguments);
                    const message = Array.from(arguments).join(' ');
                    debugContainer.innerHTML += `<div>${message}</div>`;
                    debugContainer.scrollTop = debugContainer.scrollHeight;
                };
                
                console.error = function() {
                    originalError.apply(console, arguments);
                    const message = Array.from(arguments).join(' ');
                    debugContainer.innerHTML += `<div style="color:red">${message}</div>`;
                    debugContainer.scrollTop = debugContainer.scrollHeight;
                };
            }
            
            handleMissingAssets() {
                // Create basic placeholder geometries for missing models
                if (!this.character) {
                    console.log("Creating placeholder for missing character model");
                    const geo = new THREE.CapsuleGeometry(0.5, 1, 4, 8);
                    const mat = new THREE.MeshStandardMaterial({color: 0x00ff00});
                    this.character = new THREE.Mesh(geo, mat);
                    this.character.position.set(-3, 1, 0);
                    this.scene.add(this.character);
                    
                    // Mock animation mixer to prevent errors
                    this.animations.mixer = new THREE.AnimationMixer(this.character);
                    this.animations.actions.tpose = {
                        fadeOut: () => {},
                        reset: () => {},
                        fadeIn: () => {},
                        play: () => {}
                    };
                    this.animations.current = 'tpose';
                }
                
                // Create simple car placeholder
                if (!this.car) {
                    console.log("Creating placeholder for missing car model");
                    const geo = new THREE.BoxGeometry(2, 1, 4);
                    const mat = new THREE.MeshStandardMaterial({color: 0x0000ff});
                    this.car = new THREE.Mesh(geo, mat);
                    this.car.position.set(-5, 0.5, 0);
                    this.scene.add(this.car);
                }
                
                // Create simple house placeholder
                if (!this.house) {
                    console.log("Creating placeholder for missing house model");
                    const geo = new THREE.BoxGeometry(4, 3, 4);
                    const mat = new THREE.MeshStandardMaterial({color: 0xff0000});
                    this.house = new THREE.Mesh(geo, mat);
                    this.house.position.set(5, 1.5, 0);
                    this.scene.add(this.house);
                }
                
                // Create placeholders for bags if needed
                if (this.availableBags.length === 0) {
                    console.log("Creating placeholder bags");
                    this.bag1Template = new THREE.Mesh(
                        new THREE.BoxGeometry(0.5, 0.5, 0.5),
                        new THREE.MeshStandardMaterial({color: 0xffff00})
                    );
                    this.bag2Template = new THREE.Mesh(
                        new THREE.SphereGeometry(0.3, 8, 8),
                        new THREE.MeshStandardMaterial({color: 0xff00ff})
                    );
                    this.createBagsOnCar();
                }
                
                // Hide loading screen and show game UI
                document.getElementById('loading-screen').style.display = 'none';
                document.getElementById('balance-meter').style.display = 'block';
                document.getElementById('item-counter').style.display = 'block';
                
                // Set game state to playing
                this.state.isLoading = false;
                this.state.isPlaying = true;
            }
            
            // Add a points system based on speed and balance maintenance
            calculateScore() {
                const timeBonus = Math.max(0, 100 - this.gameTimer);
                const balanceBonus = Math.floor(this.perfectBalanceTime * 10);
                const bagBonus = this.state.bagsCarried * 20;
                
                return timeBonus + balanceBonus + bagBonus;
            }
            
            // Unlockable items like better shoes for better balance,
            // stronger arms to carry more bags, etc.
            unlockUpgrade(type) {
                switch(type) {
                    case 'shoes':
                        this.playerUpgrades.balanceStability += 0.1;
                        break;
                    case 'arms':
                        this.state.maxBags += 1;
                        break;
                    case 'cart':
                        // Special item that lets player carry many bags but moves slower
                        this.playerUpgrades.hasCart = true;
                        this.state.maxBags = 10;
                        this.playerSpeed *= 0.7;
                        break;
                }
            }
            
            // Add this method to check if URLs are accessible
            checkAssetUrls() {
                const urls = Object.values(this.assets);
                let checkedCount = 0;
                
                urls.forEach(url => {
                    fetch(url, { method: 'HEAD' })
                        .then(response => {
                            if (response.ok) {
                                console.log(`✅ Asset URL valid: ${url}`);
                            } else {
                                console.error(`❌ Asset URL returns ${response.status}: ${url}`);
                                // Try alternative URL by removing/adding 'assets/' directory
                                const altUrl = url.includes('/assets/') ? 
                                    url.replace('/assets/', '/') : 
                                    url.replace('/onetrip/', '/onetrip/assets/');
                                
                                console.log(`Trying alternative URL: ${altUrl}`);
                                this.tryAlternativeUrl(url, altUrl);
                            }
                        })
                        .catch(error => {
                            console.error(`❌ Asset URL check failed: ${url}`);
                        })
                        .finally(() => {
                            checkedCount++;
                            if (checkedCount === urls.length) {
                                console.log('URL check complete');
                            }
                        });
                });
            }
            
            // Try alternative URL
            tryAlternativeUrl(originalUrl, alternativeUrl) {
                fetch(alternativeUrl, { method: 'HEAD' })
                    .then(response => {
                        if (response.ok) {
                            console.log(`✅ Alternative URL valid: ${alternativeUrl}`);
                            // Replace the URL in assets
                            Object.keys(this.assets).forEach(key => {
                                if (this.assets[key] === originalUrl) {
                                    this.assets[key] = alternativeUrl;
                                    console.log(`Updated asset URL for ${key}`);
                                }
                            });
                        } else {
                            console.error(`❌ Alternative URL also fails: ${alternativeUrl}`);
                        }
                    });
            }
        }
        
        // Initialize game when page loads
        window.onload = () => {
            new OneTripGame();
        };
    </script>
</body>
</html> 