<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>One Trip - Balance System Preview</title>
    <style>
        body { margin: 0; overflow: hidden; background: #111; }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            color: white;
            text-align: center;
            padding: 10px;
            font-family: Arial, sans-serif;
            z-index: 100;
            pointer-events: none;
        }
        #controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px;
            font-family: Arial, sans-serif;
            border-radius: 5px;
            display: none; /* Hide testing controls */
        }
        #balanceUI {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px;
            font-family: Arial, sans-serif;
            border-radius: 5px;
            display: none; /* Hide balance UI */
        }
        #pickupControls {
            position: absolute;
            left: 10px;
            top: 60px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px;
            font-family: Arial, sans-serif;
            border-radius: 5px;
            z-index: 1000;
            display: none; /* Hide pickup controls */
        }
        select, button, input {
            margin: 5px;
            padding: 5px;
        }
        #balanceMeter {
            width: 200px;
            height: 10px;
            background: rgba(255,255,255,0.3);
            border-radius: 5px;
            margin-top: 5px;
            position: relative;
        }
        #balanceIndicator {
            position: absolute;
            width: 6px;
            height: 100%;
            background: white;
            border-radius: 3px;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
        }
        .balanceZone {
            position: absolute;
            width: 20%;
            height: 100%;
            background: rgba(76,175,80,0.3);
            top: 0;
            left: 40%;
        }
        #balanceDirection {
            margin-top: 5px;
            font-weight: bold;
            text-align: center;
        }
        #pickupFeedback {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 15px 30px;
            font-family: Arial, sans-serif;
            border-radius: 5px;
            font-size: 24px;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            z-index: 2000;
        }
        #carryInfo {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px;
            font-family: Arial, sans-serif;
            border-radius: 5px;
            z-index: 1000;
        }
        #touchControls {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 50;
            pointer-events: all;
            touch-action: none;
        }
        #virtualJoystick {
            position: absolute;
            bottom: 80px;
            left: 80px;
            width: 120px;
            height: 120px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 60px;
            border: 2px solid rgba(255, 255, 255, 0.5);
            z-index: 1001;
            touch-action: none;
        }
        #joystickKnob {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 25px;
            touch-action: none;
        }
        /* Add second joystick for camera rotation */
        #rotationJoystick {
            position: absolute;
            bottom: 80px;
            right: 80px;
            width: 120px;
            height: 120px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 60px;
            border: 2px solid rgba(255, 255, 255, 0.5);
            z-index: 1001;
            touch-action: none;
        }
        #rotationJoystickKnob {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 25px;
            touch-action: none;
        }
        #interactButton {
            position: absolute;
            bottom: 100px;
            right: 220px; /* Moved to make room for rotation joystick */
            width: 80px;
            height: 80px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 40px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 24px;
            font-weight: bold;
            z-index: 1001;
            touch-action: none;
            border: 2px solid rgba(255, 255, 255, 0.8);
            text-shadow: 1px 1px 2px #000;
        }
        #interactButton.highlight {
            background: rgba(76, 175, 80, 0.7);
            transform: scale(1.1);
            transition: all 0.3s;
        }
        #helpOverlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 20px;
            font-family: Arial, sans-serif;
            border-radius: 5px;
            z-index: 3000;
            max-width: 80%;
            text-align: center;
        }
        #helpOverlay h2 {
            margin-top: 0;
            color: #4CAF50;
        }
        #helpOverlay button {
            margin-top: 10px;
            padding: 8px 16px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        #helpOverlay button:hover {
            background: #3e8e41;
        }
        #helpBtn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(76, 175, 80, 0.7);
            color: white;
            font-size: 20px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 2px solid white;
            cursor: pointer;
            z-index: 1001;
        }
        #gameViewBtn {
            position: absolute;
            top: 60px;
            right: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 5px 10px;
            font-family: Arial, sans-serif;
            border-radius: 5px;
            z-index: 1001;
        }
        #debug {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px;
            font-family: monospace;
            border-radius: 5px;
            z-index: 1001;
            font-size: 12px;
        }
        #bagInRangeIndicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: rgba(76, 175, 80, 0.7);
            border: 2px solid white;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div id="info">Loading models...</div>
    <div id="controls">
        <div>
            <label for="upperBodyAnim">Upper Body: </label>
            <select id="upperBodyAnim"></select>
        </div>
        <div>
            <label for="lowerBodyAnim">Lower Body: </label>
            <select id="lowerBodyAnim"></select>
        </div>
        <button id="gameView">Game View</button>
        <button id="resetView">Reset View</button>
    </div>
    
    <div id="pickupControls">
        <h3>Pickup Actions</h3>
        <button id="pickupLowBtn">Pickup Low (Ground)</button>
        <button id="pickupHighBtn">Pickup High (Car)</button>
        <button id="attachBagBtn">Attach Bag to Hand</button>
        <button id="detachBagBtn">Detach Bag</button>
    </div>
    
    <div id="balanceUI">
        <h3>Balance System Preview</h3>
        <div>
            <label for="balanceSlider">Balance (0-1): </label>
            <input type="range" id="balanceSlider" min="0" max="100" value="50">
            <span id="balanceValue">0.5</span>
        </div>
        <div id="balanceMeter">
            <div class="balanceZone"></div>
            <div id="balanceIndicator"></div>
        </div>
        <div id="balanceDirection">Balanced</div>
        <div>
            <button id="toggleBalance">Toggle Balance Effect</button>
            </div>
        </div>
        
    <div id="carryInfo">
        <div>Bags: <span id="bagCount">0</span></div>
        <div>Weight: <span id="totalWeight">0</span> kg</div>
        </div>
        
    <div id="pickupFeedback"></div>
    
    <div id="touchControls">
        <div id="virtualJoystick">
            <div id="joystickKnob"></div>
        </div>
        <div id="rotationJoystick">
            <div id="rotationJoystickKnob"></div>
        </div>
        <div id="interactButton">Pick</div>
    </div>

    <button id="helpBtn">?</button>
    <button id="gameViewBtn">Toggle Camera</button>
    
    <div id="debug"></div>
    
    <div id="bagInRangeIndicator"></div>
    
    <div id="helpOverlay">
        <h2>Controls</h2>
        <p><strong>Touch Controls:</strong> Left joystick to move, right joystick to rotate, button to pick up bags</p>
        <p><strong>Keyboard/Mouse:</strong> WASD or arrows to move, mouse to rotate, E or SPACE to pick up, Q or R to drop</p>
        <p><strong>Balance:</strong> Moving quickly affects balance when carrying bags</p>
        <p><strong>Tips:</strong> Get close to bags to pick them up. Ground bags use right hand, car bags use left hand.</p>
        <button id="closeHelpBtn">Got it!</button>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.147.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.147.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.147.0/examples/js/loaders/GLTFLoader.js"></script>

    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        
        // Camera setup
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.set(0, 10, 30);
        
        // Renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);
        
        // Controls for testing
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.target.set(0, 2, 0);
        controls.update();
        
        // Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(5, 10, 5);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        scene.add(directionalLight);
        
        // Ground
        const groundGeometry = new THREE.PlaneGeometry(200, 200);
        const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x7CFC00 });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);
        
        // Grid helper
        const gridHelper = new THREE.GridHelper(200, 200);
        scene.add(gridHelper);
        
        // Create text labels for each model
        function createLabel(text, position) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 64;
            
            context.fillStyle = 'rgba(0,0,0,0.7)';
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            context.font = '24px Arial';
            context.fillStyle = 'white';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(text, canvas.width/2, canvas.height/2);
            
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.MeshBasicMaterial({
                map: texture,
                transparent: true,
                side: THREE.DoubleSide
            });
            
            const geometry = new THREE.PlaneGeometry(5, 1.25);
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(position.x, position.y + 5, position.z);
            mesh.lookAt(camera.position);
            
            scene.add(mesh);
            return mesh;
        }

        // Add a path/driveway
        function createDriveway() {
            const pathGeometry = new THREE.PlaneGeometry(5, 50);
            const pathMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xBDBDBD,
                roughness: 0.9
            });
            const path = new THREE.Mesh(pathGeometry, pathMaterial);
            path.rotation.x = -Math.PI / 2;
            path.position.set(0, 0.02, 5); // Slightly above ground to prevent z-fighting
            path.receiveShadow = true;
            scene.add(path);
            
            // Add steps leading to the house
            createPorchSteps();
        }
        
        // Create porch steps leading to the house
        function createPorchSteps() {
            const stepWidth = 4;
            const stepDepth = 0.8;
            const stepMaterial = new THREE.MeshStandardMaterial({ color: 0xA0A0A0 });
            
            // Add three steps of increasing height
            for (let i = 0; i < 3; i++) {
                const stepHeight = 0.2 + (i * 0.2); // Increasing height for each step
                const stepGeometry = new THREE.BoxGeometry(stepWidth, stepHeight, stepDepth);
                const step = new THREE.Mesh(stepGeometry, stepMaterial);
                
                // Position each step - offset in z direction to line up with the house porch
                const zPosition = 28 - (i * stepDepth);
                step.position.set(0, stepHeight / 2, zPosition);
                
                step.castShadow = true;
                step.receiveShadow = true;
                
                // Mark as a collidable object
                step.userData.isCollider = true;
                
                scene.add(step);
            }
            
            // Add a porch platform
            const porchGeometry = new THREE.BoxGeometry(stepWidth, 0.8, 2);
            const porch = new THREE.Mesh(porchGeometry, stepMaterial);
            porch.position.set(0, 0.4, 25.5);
            porch.castShadow = true;
            porch.receiveShadow = true;
            porch.userData.isCollider = true;
            scene.add(porch);
        }
        createDriveway();

        // Models to load with adjusted positions
        const models = [
            // Character positioned near the car
            { name: 'Character', file: './onetrip_maincharacter.glb', position: [-15, 0, -20], scale: 0.5, rotationY: Math.PI },
            
            // Car positioned at the beginning of the path
            { name: 'Car', file: './car.glb', position: [-5, 0, -20], scale: 0.5, rotationY: Math.PI/2 },
            
            // House positioned at the end of the path (far in front)
            { name: 'House', file: './house.glb', position: [0, 0, 30], scale: 0.5, rotationY: Math.PI },
            
            // Bags ON TOP of the car - moved further back (more negative Z)
            { name: 'Car Bag 1', file: './newbag.glb', position: [-5, 3.5, -20.5], scale: 0.4, rotationY: 0 },
            { name: 'Car Bag 2', file: './bag2.glb', position: [-5, 3.5, -21.5], scale: 0.4, rotationY: Math.PI/4 },
            { name: 'Car Bag 3', file: './newbag.glb', position: [-5.5, 3.5, -20], scale: 0.4, rotationY: Math.PI/6 },
            { name: 'Car Bag 4', file: './bag2.glb', position: [-4.5, 3.5, -19.5], scale: 0.4, rotationY: -Math.PI/6 },
            
            // Bags on the GROUND near character
            { name: 'Ground Bag 1', file: './newbag.glb', position: [-13, 0, -19], scale: 0.4, rotationY: 0 },
            { name: 'Ground Bag 2', file: './bag2.glb', position: [-14, 0, -21], scale: 0.4, rotationY: Math.PI/4 },
            { name: 'Ground Bag 3', file: './newbag.glb', position: [-15, 0, -17], scale: 0.4, rotationY: Math.PI/2 },
            { name: 'Ground Bag 4', file: './bag2.glb', position: [-12, 0, -22], scale: 0.4, rotationY: -Math.PI/4 },
            
            // Environment objects properly spaced along the path
            { name: 'Tree', file: './tree.glb', position: [-10, 0, 0], scale: 0.5, rotationY: 0 },
            { name: 'Tree 2', file: './tree.glb', position: [10, 0, 10], scale: 0.4, rotationY: Math.PI/3 },
            { name: 'Rocks', file: './rocks.glb', position: [5, 0, -5], scale: 0.5, rotationY: 0 },
            { name: 'Leaves', file: './leaves.glb', position: [2, 0, 15], scale: 0.5, rotationY: 0 }
        ];

        // Animation variables
        let mixer;
        let animations = [];
        let upperBodyActions = {};
        let lowerBodyActions = {};
        let currentUpperBodyAction = null;
        let currentLowerBodyAction = null;
        let currentUpperBodyAnimation = 'walk';
        let currentLowerBodyAnimation = 'walk';
        let balanceEnabled = false; // Set to false by default now
        let balanceValue = 0.5;
        let currentBalanceDirection = "center"; // left, center, right
        let carryWeightClass = "none"; // none, light, medium, heavy
        let lastMovementState = false; // Track previous movement state
        
        // Movement and control variables
        let moveDirection = new THREE.Vector3();
        let movementSpeed = 0.03; // Reduced from 0.05
        let turnSpeed = 0.03; // Reduced from 0.05
        let isMoving = false;
        let targetRotation = 0;
        let movementAcceleration = 0;
        let maxMovementSpeed = 0.08; // Reduced from 0.1
        let cameraMode = "thirdPerson"; // thirdPerson or orbit
        
        // Animation transition variables
        let animationTransitionTime = 0.5; // Reduced from 1.2 for faster transitions
        let isAnimationTransitioning = false;
        let animationTransitionTimeout = null;
        let lastAnimationChange = 0;
        let animationChangeMinDelay = 250; // Reduced from 800ms to make animations more responsive
        
        // Joystick variables
        let joystickActive = false;
        let joystickPos = { x: 0, y: 0 };
        let joystickOrigin = { x: 0, y: 0 };
        let joystickMax = 40; // Maximum distance joystick can move
        let joystickDirection = { x: 0, y: 0 }; // Normalized direction (-1 to 1)
        
        // Add rotation joystick variables
        let rotationJoystickActive = false;
        let rotationJoystickPos = { x: 0, y: 0 };
        let rotationJoystickOrigin = { x: 0, y: 0 };
        let rotationJoystickMax = 40;
        let rotationJoystickDirection = { x: 0, y: 0 };
        
        // Mouse look variables
        let mouseLookActive = false;
        let lastMouseX = 0;
        let mouseRotationSensitivity = 0.003;
        let touchRotationSensitivity = 0.05;
        
        // DOM elements
        const balanceDirectionEl = document.getElementById('balanceDirection');
        const pickupFeedbackEl = document.getElementById('pickupFeedback');
        const bagCountEl = document.getElementById('bagCount');
        const totalWeightEl = document.getElementById('totalWeight');
        const weightClassEl = document.getElementById('weightClass');
        const joystickEl = document.getElementById('virtualJoystick');
        const joystickKnobEl = document.getElementById('joystickKnob');
        const rotationJoystickEl = document.getElementById('rotationJoystick');
        const rotationKnobEl = document.getElementById('rotationJoystickKnob');
        const interactButtonEl = document.getElementById('interactButton');
        
        // Interactive objects for touch/mouse
        let interactiveObjects = [];
        let isUsingTouch = false;
        let isDragging = false;
        let isCameraFollowing = true;
        
        // Add device detection function
        function isMobileDevice() {
            return (
                ('ontouchstart' in window) ||
                (navigator.maxTouchPoints > 0) ||
                (navigator.msMaxTouchPoints > 0) ||
                (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent))
            );
        }
        
        // Character tilt object for leaning
        let characterTilt = null;
        
        // Third-person camera setup
        let thirdPersonCamera = null;
        let thirdPersonCameraTarget = new THREE.Vector3();
        let thirdPersonCameraOffset = new THREE.Vector3(0, 3, 6);
        
        // Reference to hand bones for attaching bags
        let leftHand = null;
        let rightHand = null;
        
        // References to bags for attaching
        let groundBag1 = null;
        let groundBag2 = null;
        let groundBag3 = null;
        let groundBag4 = null;
        let carBag1 = null;
        let carBag2 = null;
        let carBag3 = null;
        let carBag4 = null;
        
        // Currently attached bags with their metadata
        let attachedBags = [];
        let totalBagWeight = 0;
        
        // Load models
        const loader = new THREE.GLTFLoader();
        let loadedCount = 0;
        let characterModel;
        
        models.forEach(model => {
            // Create label for this model
            const labelMesh = createLabel(model.name, {
                x: model.position[0],
                y: model.position[1],
                z: model.position[2]
            });
            
            loader.load(
                model.file,
                    (gltf) => {
                    const modelObj = gltf.scene;
                    
                    // Apply scale and position
                    modelObj.scale.set(model.scale, model.scale, model.scale);
                    modelObj.position.set(...model.position);
                    
                    // Apply rotation if specified
                    if (model.rotationY !== undefined) {
                        modelObj.rotation.y = model.rotationY;
                    }
                    
                    // Enable shadows
                    modelObj.traverse(node => {
                            if (node.isMesh) {
                                node.castShadow = true;
                                node.receiveShadow = true;
                            }
                        });
                        
                    scene.add(modelObj);
                    
                    // Store references to bags
                    if (model.name === 'Ground Bag 1') groundBag1 = modelObj;
                    if (model.name === 'Ground Bag 2') groundBag2 = modelObj;
                    if (model.name === 'Ground Bag 3') groundBag3 = modelObj;
                    if (model.name === 'Ground Bag 4') groundBag4 = modelObj;
                    if (model.name === 'Car Bag 1') carBag1 = modelObj;
                    if (model.name === 'Car Bag 2') carBag2 = modelObj;
                    if (model.name === 'Car Bag 3') carBag3 = modelObj;
                    if (model.name === 'Car Bag 4') carBag4 = modelObj;
                    
                    // Set up character animations and bone references
                    if (model.name === 'Character') {
                        // Create tilt container to lean the character
                        characterTilt = new THREE.Object3D();
                        characterTilt.position.copy(modelObj.position);
                        scene.add(characterTilt);
                        
                        // Remove character from scene and add to tilt container
                        scene.remove(modelObj);
                        characterTilt.add(modelObj);
                        
                        // Reset character position since it's now relative to tilt container
                        modelObj.position.set(0, 0, 0);
                        
                        characterModel = modelObj;
                        
                        // Set up third-person camera
                        setupThirdPersonCamera();
                        
                        // Create animation mixer
                        mixer = new THREE.AnimationMixer(modelObj);
                        
                        // Store animations
                        animations = gltf.animations;
                        
                        // Find hand bones for attaching bags
                        modelObj.traverse(node => {
                            if (node.isBone) {
                                if (node.name === 'mixamorigLeftHand') {
                                    leftHand = node;
                                    console.log('Found left hand bone:', node.name);
                                }
                                if (node.name === 'mixamorigRightHand') {
                                    rightHand = node;
                                    console.log('Found right hand bone:', node.name);
                                }
                            }
                        });
                        
                        // Set up animation mixing
                        setupAnimationMixing(gltf.animations);
                    }
                    
                    // Update loaded count
                    loadedCount++;
                    document.getElementById('info').textContent = 
                        `Loaded ${loadedCount}/${models.length} models`;
                    
                    if (loadedCount === models.length) {
                        document.getElementById('info').textContent = 
                            `All models loaded - Use controls to test animations and balance system`;
                        
                        // Once all models are loaded, set up collision detection
                        setupCollisionDetection();
                    }
                    },
                    (xhr) => {
                    console.log(`${model.name} ${Math.round(xhr.loaded / xhr.total * 100)}% loaded`);
                    },
                    (error) => {
                    console.error(`Error loading ${model.name}:`, error);
                    loadedCount++;
                    document.getElementById('info').textContent += 
                        `\nError loading ${model.name}`;
                }
            );
        });
        
        // Set up animation mixing system
        function setupAnimationMixing(clipsList) {
            // Create empty lists for animation dropdowns
            const upperSelect = document.getElementById('upperBodyAnim');
            const lowerSelect = document.getElementById('lowerBodyAnim');
            upperSelect.innerHTML = '';
            lowerSelect.innerHTML = '';
            
            // Upper body bone names to include
            const upperBodyBones = [
                'mixamorigSpine', 'mixamorigSpine1', 'mixamorigSpine2', 
                'mixamorigNeck', 'mixamorigHead', 'mixamorigHeadTop_End',
                'mixamorigLeftShoulder', 'mixamorigLeftArm', 'mixamorigLeftForeArm', 
                'mixamorigLeftHand', 'mixamorigLeftHandThumb1', 'mixamorigLeftHandThumb2', 
                'mixamorigLeftHandThumb3', 'mixamorigLeftHandThumb4', 'mixamorigLeftHandIndex1', 
                'mixamorigLeftHandIndex2', 'mixamorigLeftHandIndex3', 'mixamorigLeftHandIndex4',
                'mixamorigRightShoulder', 'mixamorigRightArm', 'mixamorigRightForeArm', 
                'mixamorigRightHand', 'mixamorigRightHandThumb1', 'mixamorigRightHandThumb2', 
                'mixamorigRightHandThumb3', 'mixamorigRightHandThumb4', 'mixamorigRightHandIndex1', 
                'mixamorigRightHandIndex2', 'mixamorigRightHandIndex3', 'mixamorigRightHandIndex4'
            ];
            
            // Lower body bone names to include
            const lowerBodyBones = [
                'mixamorigHips', 'mixamorigLeftUpLeg', 'mixamorigLeftLeg', 
                'mixamorigLeftFoot', 'mixamorigLeftToeBase', 'mixamorigLeftToe_End',
                'mixamorigRightUpLeg', 'mixamorigRightLeg', 'mixamorigRightFoot', 
                'mixamorigRightToeBase', 'mixamorigRightToe_End'
            ];
            
            // Process each animation
            clipsList.forEach(clip => {
                // Process the animation for upper body
                const upperBodyTracks = [];
                const lowerBodyTracks = [];
                
                // Split animation tracks into upper and lower body
                clip.tracks.forEach(track => {
                    const boneName = track.name.split('.')[0];
                    
                    if (upperBodyBones.includes(boneName)) {
                        upperBodyTracks.push(track);
                    } else if (lowerBodyBones.includes(boneName)) {
                        lowerBodyTracks.push(track);
                    }
                });
                
                // Create upper body clip
                const upperBodyClip = new THREE.AnimationClip(
                    clip.name + '_upper',
                    clip.duration,
                    upperBodyTracks
                );
                
                // Create lower body clip
                const lowerBodyClip = new THREE.AnimationClip(
                    clip.name + '_lower',
                    clip.duration,
                    lowerBodyTracks
                );
                
                // Store regular actions
                upperBodyActions[clip.name] = mixer.clipAction(upperBodyClip);
                lowerBodyActions[clip.name] = mixer.clipAction(lowerBodyClip);
                
                // Add to dropdowns
                const upperOption = document.createElement('option');
                upperOption.value = clip.name;
                upperOption.text = clip.name;
                upperSelect.add(upperOption);
                
                const lowerOption = document.createElement('option');
                lowerOption.value = clip.name;
                lowerOption.text = clip.name;
                lowerSelect.add(lowerOption);
                
                // Set default selections
                if (clip.name === 'walk') {
                    upperSelect.value = clip.name;
                    lowerSelect.value = clip.name;
                }
            });
            
            // Initialize with default animations
            setUpperBodyAnimation('walk');
            setLowerBodyAnimation('walk');
            
            console.log(`Set up ${clipsList.length} animations for mixing`);
        }
        
        // Update the animation selection and carrying code to use correct animation naming pattern
        function getAnimationNameForCarrying(baseAnimation, weightClass) {
            // If we're carrying something
            if (weightClass !== "none") {
                // Determine the movement state (walk, stand, run)
                let movementState = "stand";
                if (isMoving) {
                    // For now we only have walk, but could check speed for run later
                    movementState = "walk";
                    
                    // If we're moving fast enough, use run animation
                    if (movementAcceleration > maxMovementSpeed * 0.7) {
                        movementState = "run";
                    }
                }
                
                // Format follows: carry_[movement]_[weight] (e.g., carry_walk_medium)
                return `carry_${movementState}_${weightClass}`;
            }
            
            // Not carrying, return regular animation
            return baseAnimation;
        }

        // Function to set upper body animation
        function setUpperBodyAnimation(name) {
            // Prevent rapid animation changes
            const now = Date.now();
            if (now - lastAnimationChange < animationChangeMinDelay) { // Use variable for min delay
                updateDebug(`Ignoring animation change: too soon (${name})`);
                return; // Ignore if we just changed animations
            }
            
            updateDebug(`Setting upper body anim: ${name}`);
            
            // Check if we should use a carry animation based on weight class
            if (attachedBags.length > 0 && (name === 'walk' || name === 'idle' || name === 'run' || name.startsWith('carry'))) {
                // For carrying, we use the special format: carry_[movement]_[weight]
                name = getAnimationNameForCarrying(name, carryWeightClass);
                updateDebug(`Using carry animation: ${name}`);
            }
            
            if (!upperBodyActions[name]) {
                updateDebug(`Upper body animation '${name}' not found, falling back to walk`);
                
                // Try to find a similar animation if the exact one isn't available
                const simplifiedName = name.split('_')[0]; // Get base animation name
                
                if (simplifiedName === 'carry' && upperBodyActions['carry_walk_medium']) {
                    name = 'carry_walk_medium'; // Fallback to a default carry animation
                } else {
                    name = 'walk'; // Fallback to basic walk
                }
            }
            
            // If already playing this animation, don't restart it
            if (currentUpperBodyAnimation === name && currentUpperBodyAction) {
                updateDebug(`Already playing ${name}, not restarting`);
                return;
            }
            
            // Set animation transitioning flag
            isAnimationTransitioning = true;
            
            // Fade out current animation
            if (currentUpperBodyAction) {
                currentUpperBodyAction.fadeOut(animationTransitionTime);
            }
            
            // Play new animation
            const action = upperBodyActions[name];
            action.reset();
            action.fadeIn(animationTransitionTime);
            action.play();
            
            currentUpperBodyAction = action;
            currentUpperBodyAnimation = name;
            lastAnimationChange = now;
            
            // Clear transition flag after transition completes
            clearTimeout(animationTransitionTimeout);
            animationTransitionTimeout = setTimeout(() => {
                isAnimationTransitioning = false;
                updateDebug(`Animation transition complete: ${name}`);
            }, animationTransitionTime * 1000);
        }
        
        // Function to set lower body animation
        function setLowerBodyAnimation(name) {
            // Prevent rapid animation changes
            const now = Date.now();
            if (now - lastAnimationChange < animationChangeMinDelay) { // Use variable for min delay
                updateDebug(`Ignoring lower body animation change: too soon (${name})`);
                return; // Ignore if we just changed animations
            }
            
            // Don't change animations if we're in the middle of a transition
            if (isAnimationTransitioning) {
                updateDebug(`Ignoring animation during transition: ${name}`);
                return;
            }
            
            updateDebug(`Setting lower body anim: ${name}`);
            
            if (!lowerBodyActions[name]) {
                updateDebug(`Lower body animation '${name}' not found`);
                return;
            }
            
            // If already playing this animation, don't restart it
            if (currentLowerBodyAnimation === name && currentLowerBodyAction) {
                updateDebug(`Already playing ${name}, not restarting`);
                return;
            }
            
            // Set animation transitioning flag
            isAnimationTransitioning = true;
            
            // Fade out current animation
            if (currentLowerBodyAction) {
                currentLowerBodyAction.fadeOut(animationTransitionTime);
            }
            
            // Play new animation
            const action = lowerBodyActions[name];
            action.reset();
            action.fadeIn(animationTransitionTime);
            action.play();
            
            currentLowerBodyAction = action;
            currentLowerBodyAnimation = name;
            lastAnimationChange = now;
            
            // Clear transition flag after transition completes
            clearTimeout(animationTransitionTimeout);
            animationTransitionTimeout = setTimeout(() => {
                isAnimationTransitioning = false;
                updateDebug(`Animation transition complete: ${name}`);
            }, animationTransitionTime * 1000);
        }
        
        // Function to animate tilt smoothly using GSAP-like approach
        function gsapTilt(targetAngle) {
            if (!characterTilt) return;
            
            // Current angle
            const currentAngle = characterTilt.rotation.z;
            
            // If angles are very close, don't bother animating
            if (Math.abs(targetAngle - currentAngle) < 0.01) {
                return;
            }
            
            updateDebug(`Tilting character from ${currentAngle.toFixed(2)} to ${targetAngle.toFixed(2)}`);
            
            // Animation duration (in frames) - increased for smoother transition
            const duration = 60; // doubled from 30
            
            // Amount to change per frame
            const angleStep = (targetAngle - currentAngle) / duration;
            
            // Create a simple animation
            let frame = 0;
            
            function animateTilt() {
                if (frame >= duration) return;
                
                characterTilt.rotation.z += angleStep;
                frame++;
                
                requestAnimationFrame(animateTilt);
            }
            
            animateTilt();
        }
        
        // Function to attach a bag to the character's hand
        function attachBagToHand(bag, hand) {
            if (!bag || !hand || !characterModel) {
                console.error("Cannot attach bag - missing references:", { 
                    bag: bag ? true : false, 
                    hand: hand ? hand.name : false, 
                    character: characterModel ? true : false 
                });
                return;
            }
            
            // Check if this bag is already attached
            const existingBagIndex = attachedBags.findIndex(b => b.mesh === bag);
            if (existingBagIndex >= 0) {
                console.warn("This bag is already attached");
                showPickupFeedback("Already carrying this bag!");
                return;
            }
            
            console.log("Attaching bag to hand...");
            showPickupFeedback("Picked up bag!");
            
            // Store original parent and transform for later restoration
            const originalParent = bag.parent;
            const originalPosition = bag.position.clone();
            const originalRotation = bag.rotation.clone();
            const originalScale = bag.scale.clone();
            
            // Remove from current parent
            originalParent.remove(bag);
            
            // Create a new container for the bag to better control positioning
            const bagContainer = new THREE.Object3D();
            bagContainer.name = "BagContainer_" + attachedBags.length;
            
            // Add bag to container
            bagContainer.add(bag);
            
            // Reset bag position within container
            bag.position.set(0, 0, 0);
            
            // Attach container to hand
            hand.add(bagContainer);
            
            // Get offset position based on current attachedBags and which hand
            const isLeftHand = hand.name === 'mixamorigLeftHand';
            const handOffset = getHandOffset(isLeftHand, attachedBags.length);
            
            // Apply offset to container
            bagContainer.position.set(handOffset.x, handOffset.y, handOffset.z);
            
            // Set bag rotation appropriate for carrying
            if (isLeftHand) {
                bag.rotation.set(0, Math.PI / 2, 0); // For left hand
                // Slightly tilt bag based on hand
                bagContainer.rotation.set(0.2, 0, 0.1);
            } else {
                bag.rotation.set(0, -Math.PI / 2, 0); // For right hand
                // Slightly tilt bag based on hand
                bagContainer.rotation.set(0.2, 0, -0.1);
            }
            
            // Adjust scale to make bags more noticeable
            const handScale = 1.0; // Increased from 0.8 for better visibility
            bag.scale.set(
                originalScale.x * handScale,
                originalScale.y * handScale,
                originalScale.z * handScale
            );
            
            // Make sure the bag is visible and has proper materials
            bag.traverse(node => {
                if (node.isMesh) {
                    node.castShadow = true;
                    node.receiveShadow = true;
                    
                    // Ensure materials are visible and have good rendering properties
                    if (node.material) {
                        // Make sure material is not transparent unless it needs to be
                        node.material.transparent = false;
                        node.material.opacity = 1.0;
                        node.material.depthWrite = true;
                        node.material.depthTest = true;
                        
                        // If it's a standard material, set good rendering properties
                        if (node.material.isMeshStandardMaterial) {
                            node.material.roughness = 0.7;
                            node.material.metalness = 0.3;
                        }
                        
                        // Ensure material updates
                        node.material.needsUpdate = true;
                    }
                }
            });
            
            // Generate random weight between 1-5 kg
            const weight = Math.floor(Math.random() * 5) + 1;
            
            // Add to attached bags list with the container reference
            attachedBags.push({
                mesh: bag,
                container: bagContainer,
                originalParent: originalParent,
                originalPosition: originalPosition,
                originalRotation: originalRotation,
                originalScale: originalScale,
                hand: hand,
                weight: weight
            });
            
            // Update carrying stats
            updateCarryingStats();
            
            // Log success
            console.log("Bag attached successfully to", hand.name);
            updateDebug(`Bag attached to ${hand.name} with offset: x=${handOffset.x}, y=${handOffset.y}, z=${handOffset.z}`);
        }
        
        // Get appropriate hand offset based on which hand and how many bags are carried
        function getHandOffset(isLeftHand, bagCount) {
            // Base position for the first bag - moved further out and forward
            if (bagCount === 0) {
                return isLeftHand ? 
                    { x: 0.5, y: 0.0, z: 0.2 } : // Left hand - first bag
                    { x: -0.5, y: 0.0, z: 0.2 }; // Right hand - first bag
            }
            // Second bag position - slightly shifted from first
            else if (bagCount === 1) {
                return isLeftHand ? 
                    { x: 0.4, y: 0.2, z: 0.3 } : // Left hand - second bag (slightly above and behind)
                    { x: -0.4, y: 0.2, z: 0.3 }; // Right hand - second bag (slightly above and behind)
            }
            // Third bag position - on top
            else {
                return isLeftHand ? 
                    { x: 0.5, y: 0.4, z: 0.0 } : // Left hand - third bag (on top)
                    { x: -0.5, y: 0.4, z: 0.0 }; // Right hand - third bag (on top)
            }
        }
        
        // Show temporary pickup feedback
        function showPickupFeedback(message) {
            pickupFeedbackEl.textContent = message;
            pickupFeedbackEl.style.opacity = "1";
            
            // Add visual indication based on message type
            if (message.includes("Cannot") || message.includes("No bags") || message.includes("Wait")) {
                pickupFeedbackEl.style.background = "rgba(255, 50, 50, 0.8)";
            } else if (message.includes("Picked up") || message.includes("Grabbing") || message.includes("Picking")) {
                pickupFeedbackEl.style.background = "rgba(76, 175, 80, 0.8)";
            } else {
                pickupFeedbackEl.style.background = "rgba(0, 0, 0, 0.7)";
            }
            
                setTimeout(() => {
                pickupFeedbackEl.style.opacity = "0";
            }, 1500);
        }
        
        // Update carrying statistics with new animation naming
        function updateCarryingStats() {
            // Count bags
            bagCountEl.textContent = attachedBags.length;
            
            // Calculate total weight
            totalBagWeight = attachedBags.reduce((total, bag) => total + bag.weight, 0);
            totalWeightEl.textContent = totalBagWeight + " kg";
            
            // Show/hide balance UI based on whether bags are being carried
            const balanceUI = document.getElementById('balanceUI');
            if (attachedBags.length > 0) {
                if (balanceUI) balanceUI.style.display = 'block';
            } else {
                if (balanceUI) balanceUI.style.display = 'none';
            }
            
            // Determine weight class based on total weight or bag count
            let newWeightClass = "none";
            
            if (attachedBags.length > 0) {
                if (totalBagWeight <= 3) {
                    newWeightClass = "light";
                } else if (totalBagWeight <= 7) {
                    newWeightClass = "medium";
                } else {
                    newWeightClass = "heavy";
                }
                
                // Enable balance system when carrying bags
                if (!balanceEnabled) {
                    balanceEnabled = true;
                    updateDebug("Balance system enabled - carrying bags");
                }
            } else {
                // Disable balance system when not carrying bags
                if (balanceEnabled) {
                    balanceEnabled = false;
                    updateDebug("Balance system disabled - no bags");
                    
                    // Reset any tilt when bags are dropped
                    if (characterTilt) {
                        gsapTilt(0);
                    }
                }
            }
            
            // Update weight class display
            if (weightClassEl) weightClassEl.textContent = newWeightClass.charAt(0).toUpperCase() + newWeightClass.slice(1);
            
            // If weight class changed, update the animation
            if (newWeightClass !== carryWeightClass) {
                carryWeightClass = newWeightClass;
                
                // Update the animation based on current state and new weight class
                if (attachedBags.length > 0) {
                    // Determine the current movement state
                    const movementState = isMoving ? "walk" : "stand";
                    setUpperBodyAnimation(`carry_${movementState}_${carryWeightClass}`);
                } else {
                    // If no bags, go back to walk or idle depending on movement
                    setUpperBodyAnimation(isMoving ? 'walk' : 'idle');
                }
            }
        }
        
        // Function to detach bag
        function detachBag() {
            if (attachedBags.length === 0) {
                console.warn("No bags are currently attached");
                showPickupFeedback("No bags to drop!");
                return;
            }
            
            console.log("Detaching last bag...");
            showPickupFeedback("Dropped bag!");
            
            // Get the last attached bag
            const bagData = attachedBags.pop();
            const bag = bagData.mesh;
            const bagContainer = bagData.container;
            const originalParent = bagData.originalParent;
            
            // First, remove the bag from the container
            if (bagContainer) {
                bagContainer.remove(bag);
            }
            
            // Remove container from hand
            if (bagContainer && bagContainer.parent) {
                bagContainer.parent.remove(bagContainer);
            }
            
            // Add bag back to original parent
            originalParent.add(bag);
            
            // Restore original transform
            bag.position.copy(bagData.originalPosition);
            bag.rotation.copy(bagData.originalRotation);
            bag.scale.copy(bagData.originalScale);
            
            // Update carrying stats
            updateCarryingStats();
            
            console.log("Bag detached successfully");
            updateDebug("Bag dropped, returned to original position");
        }
        
        // Add camera shake variables
        let cameraShakeActive = false;
        let cameraShakeIntensity = 0;
        let cameraShakeDecay = 0.9;
        let cameraOriginalPosition = new THREE.Vector3();
        
        // Function to apply camera shake effect
        function applyCameraShake() {
            if (!thirdPersonCamera || !cameraShakeActive) return;
            
            // Store original position if not already stored
            if (cameraOriginalPosition.length() === 0) {
                cameraOriginalPosition.copy(thirdPersonCamera.position);
            }
            
            // Apply random offset based on intensity
            const shakeX = (Math.random() * 2 - 1) * cameraShakeIntensity;
            const shakeY = (Math.random() * 2 - 1) * cameraShakeIntensity;
            
            // Apply shake to camera position
            thirdPersonCamera.position.x = cameraOriginalPosition.x + shakeX;
            thirdPersonCamera.position.y = cameraOriginalPosition.y + shakeY;
            
            // Reduce shake intensity over time
            cameraShakeIntensity *= cameraShakeDecay;
            
            // Stop shaking when intensity gets too low
            if (cameraShakeIntensity < 0.01) {
                cameraShakeActive = false;
                cameraShakeIntensity = 0;
                cameraOriginalPosition.set(0, 0, 0);
            }
        }
        
        // Function to start camera shake with given intensity
        function startCameraShake(intensity) {
            cameraShakeIntensity = intensity;
            cameraShakeActive = true;
            cameraOriginalPosition.set(0, 0, 0); // Reset so it gets updated on next frame
        }
        
        // Function to update the balance system
        function updateBalanceSystem(value) {
            document.getElementById('balanceValue').textContent = value.toFixed(2);
            document.getElementById('balanceIndicator').style.left = `${value * 100}%`;
            
            // Change indicator color based on balance
            const indicator = document.getElementById('balanceIndicator');
            
            let newDirection = "center";
            let intensity = 0;
            
            // If not carrying bags, always stay balanced
            if (attachedBags.length === 0) {
                indicator.style.background = '#ffffff'; // White for safe
                balanceDirectionEl.textContent = "Balanced";
                balanceDirectionEl.style.color = '#ffffff';
                return;
            }
            
            // Apply weight-based balance adjustments
            // The more bags the player carries, the more sensitive their balance becomes
            let weightFactor = 1.0;
            if (totalBagWeight > 0) {
                // Each kg makes balance 8% more sensitive (reduced from 10%)
                weightFactor = 1.0 + (totalBagWeight * 0.08);
            }
            
            // Adjust thresholds based on weight
            const leftSevereThreshold = 0.3 * weightFactor; // Increased from 0.2
            const leftModerateThreshold = 0.4 * weightFactor; // Increased from 0.3
            const rightModerateThreshold = 0.6 / weightFactor; // Changed from 0.7
            const rightSevereThreshold = 0.7 / weightFactor; // Changed from 0.8
            
            if (value < leftSevereThreshold) {
                // Left imbalance (severe)
                indicator.style.background = '#ff4444'; // Red for danger
                balanceDirectionEl.textContent = "Severe Left Imbalance";
                balanceDirectionEl.style.color = '#ff4444';
                newDirection = "left";
                intensity = 0.4 - value; // Reduced range
                
                // Add camera shake for severe imbalance
                if (intensity > 0.05 && !cameraShakeActive) {
                    startCameraShake(Math.min(0.15, intensity * 0.5));
                }
            } else if (value < leftModerateThreshold) {
                // Left imbalance (moderate)
                indicator.style.background = '#ffaa44'; // Orange for warning
                balanceDirectionEl.textContent = "Left Imbalance";
                balanceDirectionEl.style.color = '#ffaa44';
                newDirection = "left";
                intensity = 0.3 - value; // 0 to 0.3 range
                
                // Add slight camera shake for moderate imbalance
                if (intensity > 0.05 && !cameraShakeActive) {
                    startCameraShake(Math.min(0.08, intensity * 0.3));
                }
            } else if (value > rightSevereThreshold) {
                // Right imbalance (severe)
                indicator.style.background = '#ff4444'; // Red for danger
                balanceDirectionEl.textContent = "Severe Right Imbalance";
                balanceDirectionEl.style.color = '#ff4444';
                newDirection = "right";
                intensity = value - 0.5; // Reduced range
                
                // Add camera shake for severe imbalance
                if (intensity > 0.05 && !cameraShakeActive) {
                    startCameraShake(Math.min(0.15, intensity * 0.5));
                }
            } else if (value > rightModerateThreshold) {
                // Right imbalance (moderate)
                indicator.style.background = '#ffaa44'; // Orange for warning
                balanceDirectionEl.textContent = "Right Imbalance";
                balanceDirectionEl.style.color = '#ffaa44';
                newDirection = "right";
                intensity = value - 0.6; // Reduced range
                
                // Add slight camera shake for moderate imbalance
                if (intensity > 0.05 && !cameraShakeActive) {
                    startCameraShake(Math.min(0.08, intensity * 0.3));
                }
            } else {
                // Balanced
                indicator.style.background = '#ffffff'; // White for safe
                balanceDirectionEl.textContent = "Balanced";
                balanceDirectionEl.style.color = '#ffffff';
                newDirection = "center";
                intensity = 0;
            }
            
            // Display carrying info in balance feedback
            if (totalBagWeight > 0) {
                balanceDirectionEl.textContent += ` (${totalBagWeight}kg)`;
            }
            
            // Apply animation based on balance if enabled
            if (balanceEnabled && newDirection !== currentBalanceDirection) {
                updateAnimationsForBalance(newDirection, intensity);
                currentBalanceDirection = newDirection;
            }
        }
        
        // Function to update animations based on balance direction
        function updateAnimationsForBalance(direction, intensity) {
            // Use stumble for lower body when imbalanced
            if (direction !== "center") {
                // If moving, use stumble_lowerbody, otherwise use default animation
                if (isMoving && !currentLowerBodyAnimation.startsWith('stumble')) {
                    setLowerBodyAnimation('stumble_lowerbody');
                }
                
                // Apply a tilt to the entire character
                if (characterTilt) {
                    // Calculate tilt angle based on intensity but with reduced maximum tilt
                    // Max tilt reduced from 0.5 to 0.3 radians (about 17 degrees instead of 29 degrees)
                    const tiltAmount = Math.min(0.2, Math.max(0, (intensity - 0.2) * 1.0 + 0.05));
                    const tiltAngle = (direction === 'left' ? -1 : 1) * tiltAmount;
                    
                    // Apply tilt with smooth transition
                    gsapTilt(tiltAngle);
                }
            } else {
                // Return to normal walking and no tilt
                if (isMoving && currentLowerBodyAnimation.startsWith('stumble')) {
                    setLowerBodyAnimation('walk');
                } else if (!isMoving && currentLowerBodyAnimation.startsWith('stumble')) {
                    setLowerBodyAnimation('idle');
                }
                
                if (characterTilt) {
                    gsapTilt(0);
                }
            }
        }
        
        // Set up UI event listeners
        document.getElementById('upperBodyAnim').addEventListener('change', function() {
            setUpperBodyAnimation(this.value);
        });
        
        document.getElementById('lowerBodyAnim').addEventListener('change', function() {
            if (!balanceEnabled || currentBalanceDirection === 'center') {
                setLowerBodyAnimation(this.value);
            } else {
                alert("Can't change lower body animation while balance effect is active. Disable balance effect first.");
                this.value = currentLowerBodyAnimation;
            }
        });
        
        document.getElementById('pickupLowBtn').addEventListener('click', function() {
            setUpperBodyAnimation('pickup_low');
            
            // After a short delay, attempt to pick up a ground bag
                    setTimeout(() => {
                if (rightHand && groundBag1 && !attachedBags.some(b => b.mesh === groundBag1)) {
                    attachBagToHand(groundBag1, rightHand);
                } else if (rightHand && groundBag2 && !attachedBags.some(b => b.mesh === groundBag2)) {
                    attachBagToHand(groundBag2, rightHand);
                } else {
                    showPickupFeedback("No more ground bags to pick up!");
                }
            }, 500); // 500ms delay to match animation timing
        });
        
        document.getElementById('pickupHighBtn').addEventListener('click', function() {
            setUpperBodyAnimation('pickup_high');
            
            // After a short delay, attempt to pick up a car bag
            setTimeout(() => {
                if (leftHand && carBag1 && !attachedBags.some(b => b.mesh === carBag1)) {
                    attachBagToHand(carBag1, leftHand);
                } else if (leftHand && carBag2 && !attachedBags.some(b => b.mesh === carBag2)) {
                    attachBagToHand(carBag2, leftHand);
                } else {
                    showPickupFeedback("No more car bags to pick up!");
                }
            }, 500); // 500ms delay to match animation timing
        });
        
        document.getElementById('attachBagBtn').addEventListener('click', function() {
            // Try to find an available bag and hand
            let availableBag = null;
            let targetHand = null;
            
            // Check for available ground bags first
            if (groundBag1 && !attachedBags.some(b => b.mesh === groundBag1)) {
                availableBag = groundBag1;
                targetHand = rightHand;
            } else if (groundBag2 && !attachedBags.some(b => b.mesh === groundBag2)) {
                availableBag = groundBag2;
                targetHand = rightHand;
            } 
            // Check for car bags next
            else if (carBag1 && !attachedBags.some(b => b.mesh === carBag1)) {
                availableBag = carBag1;
                targetHand = leftHand;
            } else if (carBag2 && !attachedBags.some(b => b.mesh === carBag2)) {
                availableBag = carBag2;
                targetHand = leftHand;
            }
            
            // Attach if we found an available bag and hand
            if (availableBag && targetHand) {
                attachBagToHand(availableBag, targetHand);
            } else {
                showPickupFeedback("No more bags to pick up!");
            }
        });
        
        document.getElementById('detachBagBtn').addEventListener('click', function() {
            detachBag();
        });
        
        document.getElementById('balanceSlider').addEventListener('input', function() {
            balanceValue = this.value / 100;
            updateBalanceSystem(balanceValue);
        });
        
        document.getElementById('toggleBalance').addEventListener('click', function() {
            balanceEnabled = !balanceEnabled;
            this.textContent = balanceEnabled ? 
                'Disable Balance Effect' : 'Enable Balance Effect';
            
            // Apply current balance state immediately when toggled
            updateBalanceSystem(balanceValue);
        });
        
        document.getElementById('gameView').addEventListener('click', () => {
            camera.position.set(-17, 2, -25);
            controls.target.set(-15, 1, -20);
            controls.update();
        });
        
        document.getElementById('resetView').addEventListener('click', () => {
            camera.position.set(0, 20, 30);
            controls.target.set(0, 0, 0);
            controls.update();
        });
        
        // Function to update the balance system based on movement and turning
        function updateMovementBasedBalance() {
            // Only apply balance effects when carrying bags
            if (!balanceEnabled || attachedBags.length === 0) return;
            
            // Calculate balance shifts based on movement and turning
            let balanceShift = 0;
            
            // Movement speed affects balance - reduced sensitivity
            balanceShift += movementAcceleration * 0.15; // Reduced from 0.3
            
            // Turning affects balance - reduced sensitivity
            if (Math.abs(targetRotation - characterTilt.rotation.y) > 0.1) { // Increased threshold from 0.05 to 0.1
                const turnDirection = ((targetRotation - characterTilt.rotation.y) + Math.PI) % (Math.PI * 2) - Math.PI;
                balanceShift += turnDirection * 0.005; // Reduced from 0.01
            }
            
            // Carrying weight makes balance harder
            const carryFactor = 1 + (totalBagWeight * 0.02); // Reduced from 0.03
            balanceShift *= carryFactor;
            
            // Apply changes to balance value with smoothing and reduced rate of change
            balanceValue = Math.max(0, Math.min(1, balanceValue + (balanceShift * 0.5))); // Added 0.5 multiplier to slow changes
            
            // Update the UI
            document.getElementById('balanceSlider').value = balanceValue * 100;
            updateBalanceSystem(balanceValue);
        }
        
        // Set up third-person camera
        function setupThirdPersonCamera() {
            thirdPersonCamera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
            
            // Adjust the camera offset for a better view behind the character
            thirdPersonCameraOffset = new THREE.Vector3(0, 3, 6); // Position camera slightly higher and closer
            
            updateThirdPersonCamera();
        }
        
        // Update third-person camera position for better view
        function updateThirdPersonCamera() {
            if (!characterTilt || !thirdPersonCamera) return;
            
            // Get character position and rotation
            const characterPos = new THREE.Vector3();
            characterTilt.getWorldPosition(characterPos);
            
            // Calculate camera position based on character position and rotation
            const cameraOffset = thirdPersonCameraOffset.clone();
            cameraOffset.applyAxisAngle(new THREE.Vector3(0, 1, 0), characterTilt.rotation.y);
            
            // Set camera position and target
            thirdPersonCamera.position.copy(characterPos).add(cameraOffset);
            thirdPersonCameraTarget.copy(characterPos);
            thirdPersonCameraTarget.y += 1.5; // Look slightly above character's feet
            thirdPersonCamera.lookAt(thirdPersonCameraTarget);
        }
        
        // Update character movement and fix orientation
        function updateCharacterMovement(delta) {
            if (!characterTilt) return;
            
            // Store previous movement state to detect changes
            const wasMoving = isMoving;
            isMoving = false;
            
            // Get joystick or keyboard input for movement
            let inputX = 0;
            let inputZ = 0;
            
            // Process joystick input if active
            if (joystickActive) {
                // Add a small deadzone to prevent tiny movements
                if (Math.abs(joystickDirection.x) > 0.15) {
                    inputX = joystickDirection.x;
                }
                if (Math.abs(joystickDirection.y) > 0.15) {
                    inputZ = joystickDirection.y;
                }
            } 
            // Otherwise process keyboard input
            else {
                // W or Up Arrow - Forward movement relative to camera
                if (keysPressed['w'] || keysPressed['ArrowUp']) {
                    inputZ = -1;
                }
                // S or Down Arrow - Backward movement relative to camera
                if (keysPressed['s'] || keysPressed['ArrowDown']) {
                    inputZ = 1;
                }
                // A or Left Arrow - Strafe left relative to camera
                if (keysPressed['a'] || keysPressed['ArrowLeft']) {
                    inputX = -1;
                }
                // D or Right Arrow - Strafe right relative to camera
                if (keysPressed['d'] || keysPressed['ArrowRight']) {
                    inputX = 1;
                }
            }
            
            // Handle rotation based on input device
            if (isUsingTouch) {
                // For touch devices, use the rotation joystick to rotate the character and camera together
                if (rotationJoystickActive) {
                    const rotationAmount = rotationJoystickDirection.x * touchRotationSensitivity;
                    characterTilt.rotation.y += rotationAmount;
                    
                    // Update target rotation for balance system
                    targetRotation = characterTilt.rotation.y;
                    
                    // Update camera to follow character rotation
                    updateThirdPersonCamera();
                    
                    // When carrying bags, use joystick rotation to affect balance
                    if (attachedBags.length > 0 && balanceEnabled) {
                        // Rotation joystick movements add subtle balance shifts
                        // Speed of rotation causes more balance disruption
                        const balanceDisruption = Math.min(0.01, Math.abs(rotationAmount) * 0.3);
                        
                        // If rotation is to the right, shift balance left
                        if (rotationAmount > 0) {
                            balanceValue = Math.max(0, balanceValue - balanceDisruption);
                        } 
                        // If rotation is to the left, shift balance right
                        else if (rotationAmount < 0) {
                            balanceValue = Math.min(1, balanceValue + balanceDisruption);
                        }
                        
                        // Update the UI and apply effects
                        document.getElementById('balanceSlider').value = balanceValue * 100;
                        updateBalanceSystem(balanceValue);
                    }
                }
            }
            // For desktop, rotation is handled by mouse movement in the mousemove event handler
            
            // Process movement input (independent of rotation)
            if (Math.abs(inputX) > 0.1 || Math.abs(inputZ) > 0.1) {
                isMoving = true;
                
                // Calculate movement speed with acceleration/deceleration
                const targetSpeed = maxMovementSpeed * Math.sqrt(inputX*inputX + inputZ*inputZ);
                const speedDiff = targetSpeed - movementAcceleration;
                movementAcceleration += speedDiff * 0.08;
                
                // Create movement vector based on current camera perspective
                const cameraForward = new THREE.Vector3(0, 0, -1);
                const cameraRight = new THREE.Vector3(1, 0, 0);
                
                if (cameraMode === "thirdPerson" && thirdPersonCamera) {
                    // Get camera's forward and right vectors
                    thirdPersonCamera.getWorldDirection(cameraForward);
                    cameraForward.y = 0; // Keep movement on horizontal plane
                    cameraForward.normalize();
                    
                    // Right is perpendicular to forward in horizontal plane
                    cameraRight.crossVectors(new THREE.Vector3(0, 1, 0), cameraForward);
                } else {
                    // Use character's orientation for non-third-person
                    cameraForward.set(0, 0, -1).applyAxisAngle(new THREE.Vector3(0, 1, 0), characterTilt.rotation.y);
                    cameraRight.set(1, 0, 0).applyAxisAngle(new THREE.Vector3(0, 1, 0), characterTilt.rotation.y);
                }
                
                // Calculate movement direction relative to camera
                moveDirection.set(0, 0, 0)
                    .add(cameraRight.multiplyScalar(inputX))
                    .add(cameraForward.multiplyScalar(-inputZ));
                
                moveDirection.normalize().multiplyScalar(movementAcceleration);
                
                // Update character position
                const oldPosition = characterTilt.position.clone();
                const newPosition = oldPosition.clone().add(moveDirection);
                
                // Check for collisions before applying movement
                if (!checkCollision(oldPosition, moveDirection)) {
                    // No collision, move normally
                    characterTilt.position.copy(newPosition);
                    
                    // Check if we need to handle step climbing
                    handleStepClimbing(characterTilt.position, moveDirection);
                } else {
                    // Collision detected, try to slide along the obstacle
                    updateDebug("Collision detected, attempting to slide");
                    
                    // Try moving only in X direction
                    const xMovement = new THREE.Vector3(moveDirection.x, 0, 0);
                    if (xMovement.length() > 0.01 && !checkCollision(oldPosition, xMovement)) {
                        characterTilt.position.add(xMovement);
                    }
                    
                    // Try moving only in Z direction
                    const zMovement = new THREE.Vector3(0, 0, moveDirection.z);
                    if (zMovement.length() > 0.01 && !checkCollision(oldPosition, zMovement)) {
                        characterTilt.position.add(zMovement);
                    }
                }
                
                // If moving, rotate character mesh to face movement direction (always face the way you're moving)
                if (characterModel && moveDirection.length() > 0.01) {
                    // Get current rotation of character mesh (not tilt container)
                    const angle = Math.atan2(moveDirection.x, moveDirection.z);
                    
                    // Apply the rotation to the character model, not the tilt container
                    characterModel.rotation.y = angle;
                }
                
                // Update animations based on movement state change - ONLY if state actually changed
                if (!wasMoving || !lastMovementState) {
                    // Just started moving or continuing to move
                    if (!wasMoving) {
                        updateDebug("State change: idle → moving");
                    }
                    
                    // Force animation update on movement state change, overriding the time check
                    if (attachedBags.length > 0) {
                        const animName = `carry_walk_${carryWeightClass}`;
                        updateDebug(`Forcing animation update to: ${animName}`);
                        
                        // Bypass the time check in setUpperBodyAnimation
                        forcedAnimationUpdate(animName);
                    } else {
                        forcedAnimationUpdate('walk');
                    }
                    
                    if (currentBalanceDirection === "center") {
                        setLowerBodyAnimation('walk');
                    } else {
                        setLowerBodyAnimation('stumble_lowerbody');
                    }
                    lastMovementState = true;
                }
            } else {
                // Character is not moving, slow down gradually
                movementAcceleration *= 0.8;
                if (movementAcceleration < 0.001) {
                    movementAcceleration = 0;
                }
                
                // Update animations for idle state ONLY if we were previously moving
                if (wasMoving && lastMovementState) {
                    // Just stopped moving
                    updateDebug("State change: moving → idle");
                    
                    if (!currentUpperBodyAnimation.startsWith('pickup')) {
                        if (attachedBags.length > 0) {
                            // Force animation update, bypassing the time check
                            forcedAnimationUpdate(`carry_stand_${carryWeightClass}`);
                        } else {
                            forcedAnimationUpdate('idle');
                        }
                    }
                    
                    if (!currentLowerBodyAnimation.startsWith('stumble') && currentLowerBodyAnimation !== 'idle') {
                        setLowerBodyAnimation('idle');
                    }
                    lastMovementState = false;
                }
            }
            
            // Update balance based on movement and carrying
            updateMovementBasedBalance();
            
            // Update camera if in third-person mode and following
            if (cameraMode === "thirdPerson" && isCameraFollowing) {
                updateThirdPersonCamera();
            }
        }
        
        // Force animation update without time constraints for important state changes
        function forcedAnimationUpdate(name) {
            // Skip "too soon" check for state transitions
            
            updateDebug(`Forcing animation: ${name}`);
            
            // Check if we should use a carry animation based on weight class
            if (attachedBags.length > 0 && (name === 'walk' || name === 'idle' || name === 'run')) {
                // For carrying, use the special format
                name = getAnimationNameForCarrying(name, carryWeightClass);
                updateDebug(`Using forced carry animation: ${name}`);
            }
            
            if (!upperBodyActions[name]) {
                updateDebug(`Animation '${name}' not found, falling back`);
                
                // Try to find a similar animation if the exact one isn't available
                const simplifiedName = name.split('_')[0]; // Get base animation name
                
                if (simplifiedName === 'carry' && upperBodyActions['carry_walk_medium']) {
                    name = 'carry_walk_medium'; // Fallback to a default carry animation
                } else {
                    name = 'walk'; // Fallback to basic walk
                }
            }
            
            // If already playing this animation, don't restart it
            if (currentUpperBodyAnimation === name && currentUpperBodyAction) {
                updateDebug(`Already playing ${name}, not restarting`);
                return;
            }
            
            // Set animation transitioning flag
            isAnimationTransitioning = true;
            
            // Fade out current animation
            if (currentUpperBodyAction) {
                currentUpperBodyAction.fadeOut(animationTransitionTime);
            }
            
            // Play new animation
            const action = upperBodyActions[name];
            action.reset();
            action.fadeIn(animationTransitionTime);
            action.play();
            
            currentUpperBodyAction = action;
            currentUpperBodyAnimation = name;
            lastAnimationChange = Date.now();
            
            // Clear transition flag after transition completes
            clearTimeout(animationTransitionTimeout);
            animationTransitionTimeout = setTimeout(() => {
                isAnimationTransitioning = false;
                updateDebug(`Animation transition complete: ${name}`);
            }, animationTransitionTime * 1000);
        }
        
        // Set up joystick controls
        function setupJoystickControls() {
            const joystick = document.getElementById('virtualJoystick');
            const knob = document.getElementById('joystickKnob');
            const rotationJoystick = document.getElementById('rotationJoystick');
            const rotationKnob = document.getElementById('rotationJoystickKnob');
            const interact = document.getElementById('interactButton');
            const touchControls = document.getElementById('touchControls');
            
            // Check if we're on mobile or desktop
            isUsingTouch = isMobileDevice();
            
            // Show/hide appropriate controls based on device
            if (isUsingTouch) {
                // Mobile - show touch controls
                if (touchControls) touchControls.style.display = 'block';
            } else {
                // Desktop - hide touch controls
                if (touchControls) touchControls.style.display = 'none';
            }
            
            // Get joystick positions
            const joystickRect = joystick.getBoundingClientRect();
            joystickOrigin = {
                x: joystickRect.left + joystickRect.width / 2,
                y: joystickRect.top + joystickRect.height / 2
            };
            
            const rotationJoystickRect = rotationJoystick.getBoundingClientRect();
            rotationJoystickOrigin = {
                x: rotationJoystickRect.left + rotationJoystickRect.width / 2,
                y: rotationJoystickRect.top + rotationJoystickRect.height / 2
            };
            
            // Touch events for movement joystick
            joystick.addEventListener('touchstart', function(e) {
                e.preventDefault();
                joystickActive = true;
                updateJoystickPosition(e.touches[0].clientX, e.touches[0].clientY);
            });
            
            // Touch events for rotation joystick
            rotationJoystick.addEventListener('touchstart', function(e) {
                e.preventDefault();
                rotationJoystickActive = true;
                updateRotationJoystickPosition(e.touches[0].clientX, e.touches[0].clientY);
            });
            
            // Touch move for all joysticks
            document.addEventListener('touchmove', function(e) {
                e.preventDefault();
                isUsingTouch = true;
                
                // Handle multiple touches
                for (let i = 0; i < e.touches.length; i++) {
                    const touch = e.touches[i];
                    
                    // Check which joystick this touch belongs to
                    const touchX = touch.clientX;
                    const touchY = touch.clientY;
                    
                    // Distance to movement joystick origin
                    const moveJoystickDist = Math.sqrt(
                        Math.pow(touchX - joystickOrigin.x, 2) + 
                        Math.pow(touchY - joystickOrigin.y, 2)
                    );
                    
                    // Distance to rotation joystick origin
                    const rotateJoystickDist = Math.sqrt(
                        Math.pow(touchX - rotationJoystickOrigin.x, 2) + 
                        Math.pow(touchY - rotationJoystickOrigin.y, 2)
                    );
                    
                    // Update the appropriate joystick
                    if (moveJoystickDist < rotateJoystickDist && joystickActive) {
                        updateJoystickPosition(touchX, touchY);
                    } else if (rotationJoystickActive) {
                        updateRotationJoystickPosition(touchX, touchY);
                    }
                }
            });
            
            document.addEventListener('touchend', function(e) {
                // Need to check which joystick was released
                if (e.touches.length === 0) {
                    // All touches ended
                    joystickActive = false;
                    rotationJoystickActive = false;
                    resetJoystick();
                    resetRotationJoystick();
                } else {
                    // Some touches remain - figure out which joystick lost its touch
                    let moveJoystickTouched = false;
                    let rotateJoystickTouched = false;
                    
                    for (let i = 0; i < e.touches.length; i++) {
                        const touch = e.touches[i];
                        const touchX = touch.clientX;
                        const touchY = touch.clientY;
                        
                        // Check distances to each joystick
                        const moveJoystickDist = Math.sqrt(
                            Math.pow(touchX - joystickOrigin.x, 2) + 
                            Math.pow(touchY - joystickOrigin.y, 2)
                        );
                        
                        const rotateJoystickDist = Math.sqrt(
                            Math.pow(touchX - rotationJoystickOrigin.x, 2) + 
                            Math.pow(touchY - rotationJoystickOrigin.y, 2)
                        );
                        
                        if (moveJoystickDist < 150) moveJoystickTouched = true;
                        if (rotateJoystickDist < 150) rotateJoystickTouched = true;
                    }
                    
                    if (!moveJoystickTouched) {
                        joystickActive = false;
                        resetJoystick();
                    }
                    
                    if (!rotateJoystickTouched) {
                        rotationJoystickActive = false;
                        resetRotationJoystick();
                    }
                }
            });
            
            // Desktop-specific mouse controls (only if not mobile)
            if (!isUsingTouch) {
                // Mouse move for camera rotation (no need to click and hold)
                renderer.domElement.addEventListener('mousemove', function(e) {
                    if (cameraMode === "thirdPerson" && !controls.enabled) {
                        // Only rotate camera if in game view mode
                        const dx = e.movementX || e.mozMovementX || e.webkitMovementX || 0;
                        if (dx !== 0 && mouseLookActive) {
                            // Rotate the character AND camera together
                            characterTilt.rotation.y -= dx * mouseRotationSensitivity;
                            targetRotation = characterTilt.rotation.y;
                            
                            // Update camera to match character rotation
                            updateThirdPersonCamera();
                            
                            // When carrying bags, use mouse movement to affect balance
                            if (attachedBags.length > 0 && balanceEnabled) {
                                // Mouse movements add subtle balance shifts
                                // Faster mouse movements cause more balance disruption
                                const balanceDisruption = Math.min(0.01, Math.abs(dx) * 0.0001);
                                
                                // If movement is to the left, shift balance left
                                if (dx > 0) {
                                    balanceValue = Math.max(0, balanceValue - balanceDisruption);
                                } 
                                // If movement is to the right, shift balance right
                                else if (dx < 0) {
                                    balanceValue = Math.min(1, balanceValue + balanceDisruption);
                                }
                                
                                // Update the UI and apply effects
                                document.getElementById('balanceSlider').value = balanceValue * 100;
                                updateBalanceSystem(balanceValue);
                            }
                        }
                    }
                });
                
                // Capture pointer for smoother mouse movement
                renderer.domElement.addEventListener('click', function() {
                    if (cameraMode === "thirdPerson" && !mouseLookActive && !controls.enabled) {
                        // Request pointer lock for smoother mouse controls
                        renderer.domElement.requestPointerLock = 
                            renderer.domElement.requestPointerLock || 
                            renderer.domElement.mozRequestPointerLock || 
                            renderer.domElement.webkitRequestPointerLock;
                        
                        renderer.domElement.requestPointerLock();
                        
                        // Show a small notification to indicate pointer is locked
                        showPickupFeedback("Mouse locked - press ESC to unlock");
                    }
                });
                
                // Add ESC key handler to exit pointer lock
                document.addEventListener('keydown', function(e) {
                    if (e.key === 'Escape' && mouseLookActive) {
                        document.exitPointerLock = document.exitPointerLock || 
                            document.mozExitPointerLock || 
                            document.webkitExitPointerLock;
                            
                        document.exitPointerLock();
                    }
                });
            } else {
                // Mobile-specific mouse events for testing on desktop
                joystick.addEventListener('mousedown', function(e) {
                    e.preventDefault();
                    joystickActive = true;
                    updateJoystickPosition(e.clientX, e.clientY);
                });
                
                rotationJoystick.addEventListener('mousedown', function(e) {
                    e.preventDefault();
                    rotationJoystickActive = true;
                    updateRotationJoystickPosition(e.clientX, e.clientY);
                });
                
                document.addEventListener('mousemove', function(e) {
                    if (joystickActive) {
                        e.preventDefault();
                        updateJoystickPosition(e.clientX, e.clientY);
                    }
                    if (rotationJoystickActive) {
                        e.preventDefault();
                        updateRotationJoystickPosition(e.clientX, e.clientY);
                    }
                });
                
                document.addEventListener('mouseup', function() {
                    joystickActive = false;
                    rotationJoystickActive = false;
                    resetJoystick();
                    resetRotationJoystick();
                });
            }
            
            // Mouse right-click for rotation - disabled for new control scheme
            renderer.domElement.addEventListener('contextmenu', function(e) {
                e.preventDefault(); // Prevent right-click menu
            });
            
            // Interact button for pickups - use keyboard for desktop, touch for mobile
            if (isUsingTouch) {
                interact.addEventListener('touchstart', function(e) {
                    e.preventDefault();
                    attemptPickupInteraction();
                });
            } else {
                // For desktop, keyboard controls will handle pickups
                // Hide the interact button
                if (interact) interact.style.display = 'none';
            }
            
            // Camera toggle button
            document.getElementById('gameViewBtn').addEventListener('click', function() {
                toggleCameraMode();
            });
            
            // Update joystick origins on window resize
            window.addEventListener('resize', function() {
                const joystickRect = joystick.getBoundingClientRect();
                joystickOrigin = {
                    x: joystickRect.left + joystickRect.width / 2,
                    y: joystickRect.top + joystickRect.height / 2
                };
                
                const rotationJoystickRect = rotationJoystick.getBoundingClientRect();
                rotationJoystickOrigin = {
                    x: rotationJoystickRect.left + rotationJoystickRect.width / 2,
                    y: rotationJoystickRect.top + rotationJoystickRect.height / 2
                };
            });
            
            // Check for pointer lock change
            document.addEventListener('pointerlockchange', handlePointerLockChange);
            document.addEventListener('mozpointerlockchange', handlePointerLockChange);
            document.addEventListener('webkitpointerlockchange', handlePointerLockChange);
            
            function handlePointerLockChange() {
                if (document.pointerLockElement === renderer.domElement || 
                    document.mozPointerLockElement === renderer.domElement ||
                    document.webkitPointerLockElement === renderer.domElement) {
                    // Pointer is locked - enable camera movement
                    mouseLookActive = true;
                } else {
                    // Pointer is unlocked - disable camera movement
                    mouseLookActive = false;
                }
            }
        }
        
        // Update joystick position and calculate direction
        function updateJoystickPosition(x, y) {
            // Calculate distance from joystick center
            const dx = x - joystickOrigin.x;
            const dy = y - joystickOrigin.y;
            const distance = Math.sqrt(dx*dx + dy*dy);
            
            // Limit joystick movement to maximum radius
            const angle = Math.atan2(dy, dx);
            const limitedDistance = Math.min(distance, joystickMax);
            
            // Calculate new joystick knob position
            joystickPos = {
                x: Math.cos(angle) * limitedDistance,
                y: Math.sin(angle) * limitedDistance
            };
            
            // Update joystick knob element position
            const joystickKnobEl = document.getElementById('joystickKnob');
            joystickKnobEl.style.transform = `translate(calc(-50% + ${joystickPos.x}px), calc(-50% + ${joystickPos.y}px))`;
            
            // Calculate normalized direction for movement (-1 to 1)
            joystickDirection = {
                x: joystickPos.x / joystickMax,
                y: joystickPos.y / joystickMax
            };
        }
        
        // Update rotation joystick position
        function updateRotationJoystickPosition(x, y) {
            // Calculate distance from joystick center
            const dx = x - rotationJoystickOrigin.x;
            const dy = y - rotationJoystickOrigin.y;
            const distance = Math.sqrt(dx*dx + dy*dy);
            
            // Limit joystick movement to maximum radius
            const angle = Math.atan2(dy, dx);
            const limitedDistance = Math.min(distance, rotationJoystickMax);
            
            // Calculate new joystick knob position
            rotationJoystickPos = {
                x: Math.cos(angle) * limitedDistance,
                y: Math.sin(angle) * limitedDistance
            };
            
            // Update joystick knob element position
            const rotationKnobEl = document.getElementById('rotationJoystickKnob');
            rotationKnobEl.style.transform = `translate(calc(-50% + ${rotationJoystickPos.x}px), calc(-50% + ${rotationJoystickPos.y}px))`;
            
            // Calculate normalized direction for rotation (-1 to 1)
            rotationJoystickDirection = {
                x: rotationJoystickPos.x / rotationJoystickMax,
                y: rotationJoystickPos.y / rotationJoystickMax
            };
        }
        
        // Reset joystick to center position
        function resetJoystick() {
            joystickPos = { x: 0, y: 0 };
            joystickDirection = { x: 0, y: 0 };
            const joystickKnobEl = document.getElementById('joystickKnob');
            joystickKnobEl.style.transform = 'translate(-50%, -50%)';
        }
        
        // Reset rotation joystick to center
        function resetRotationJoystick() {
            rotationJoystickPos = { x: 0, y: 0 };
            rotationJoystickDirection = { x: 0, y: 0 };
            const rotationKnobEl = document.getElementById('rotationJoystickKnob');
            rotationKnobEl.style.transform = 'translate(-50%, -50%)';
        }
        
        // Toggle between third-person and orbit camera modes
        function toggleCameraMode() {
            if (cameraMode === "thirdPerson") {
                // Switch to orbit mode
                cameraMode = "orbit";
                isCameraFollowing = false;
                
                // Enable orbit controls
                controls.enabled = true;
                
                // Exit pointer lock if active
                if (document.pointerLockElement === renderer.domElement ||
                    document.mozPointerLockElement === renderer.domElement ||
                    document.webkitPointerLockElement === renderer.domElement) {
                    document.exitPointerLock = document.exitPointerLock || 
                        document.mozExitPointerLock || 
                        document.webkitExitPointerLock;
                    document.exitPointerLock();
                }
                
                // Set orbit camera
                camera.position.set(0, 20, 30);
                controls.target.set(0, 0, 0);
                controls.update();
                
                document.getElementById('gameViewBtn').textContent = 'Game View';
            } else {
                // Switch to third-person mode
                cameraMode = "thirdPerson";
                isCameraFollowing = true;
                
                // Disable orbit controls
                controls.enabled = false;
                
                // Re-enable third-person camera
                updateThirdPersonCamera();
                
                document.getElementById('gameViewBtn').textContent = 'Orbit View';
            }
        }
        
        // Store keyboard state
        const keysPressed = {};
        
        // Keyboard event listeners
        window.addEventListener('keydown', function(e) {
            keysPressed[e.key.toLowerCase()] = true;
            
            // Space or E = interact/pickup
            if (e.key === ' ' || e.key.toLowerCase() === 'e') {
                attemptPickupInteraction();
            }
            
            // Q or R = drop bag
            if (e.key.toLowerCase() === 'q' || e.key.toLowerCase() === 'r') {
                detachBag();
            }
            
            // Escape = close help overlay
            if (e.key === 'Escape') {
                document.getElementById('helpOverlay').style.display = 'none';
            }
        });
        
        window.addEventListener('keyup', function(e) {
            keysPressed[e.key.toLowerCase()] = false;
        });
        
        // Animation loop
        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            
            const delta = clock.getDelta();
            
            // Update character movement
            updateCharacterMovement(delta);
            
            // Update character animations
            if (mixer) mixer.update(delta);
            
            // Apply camera shake if active
            if (cameraShakeActive) {
                applyCameraShake();
            }
            
            // Update pickup button highlight
            updatePickupButtonHighlight();
            
            // Update label orientations
            scene.children.forEach(child => {
                if (child.material && child.material.map && 
                    child.material.map.isCanvasTexture) {
                    if (cameraMode === "thirdPerson" && thirdPersonCamera) {
                        child.lookAt(thirdPersonCamera.position);
                    } else {
                        child.lookAt(camera.position);
                    }
                }
            });
            
            // Render scene with appropriate camera
            if (cameraMode === "thirdPerson" && thirdPersonCamera) {
                renderer.render(scene, thirdPersonCamera);
            } else {
                renderer.render(scene, camera);
            }
        }
        animate();
        
        // Initialize controls when everything is loaded
        window.addEventListener('load', function() {
            setupJoystickControls();
            
            // Hide debug elements and optimize UI for the current device
            hideDebugElements();
            optimizeUIForDevice();
            
            // Start with balance system disabled
            document.getElementById('toggleBalance').textContent = 'Enable Balance Effect';
            document.getElementById('helpOverlay').style.display = 'block'; // Show help on start
            
            // Set initial balance to center
            balanceValue = 0.5;
            document.getElementById('balanceSlider').value = 50;
            updateBalanceSystem(balanceValue);
            
            // Set default camera mode
            cameraMode = "thirdPerson";
            isCameraFollowing = true;
            
            // For desktop mode, disable orbit controls by default
            if (!isUsingTouch) {
                controls.enabled = false;
                document.getElementById('gameViewBtn').textContent = 'Orbit View';
            }
            
            // Add help button event listener
            document.getElementById('helpBtn').addEventListener('click', function() {
                document.getElementById('helpOverlay').style.display = 'block';
            });
            
            // Update help text based on device
            const helpText = document.querySelector('#helpOverlay p:first-of-type');
            if (helpText) {
                if (isUsingTouch) {
                    helpText.textContent = "Touch Controls: Left joystick to move, right joystick to rotate, button to pick up bags";
                } else {
                    helpText.textContent = "Keyboard/Mouse: WASD or arrows to move, mouse to look around, E or SPACE to pick up, Q or R to drop";
                }
            }
            
            // Add a simple debug message
            updateDebug('Game loaded successfully');
            updateDebug(isUsingTouch ? 'Using touch controls' : 'Using desktop controls');
        });
        
        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Function to detect what kind of bag is in view
        function findInteractableBagInViewDirection() {
            // Create a raycaster from the appropriate camera
            const raycaster = new THREE.Raycaster();
            const mousePos = new THREE.Vector2(0, 0); // Center of screen
            
            // Use the active camera (third person or orbit)
            const activeCamera = (cameraMode === "thirdPerson" && thirdPersonCamera) ? 
                thirdPersonCamera : camera;
            
            // Set raycaster from camera center
            raycaster.setFromCamera(mousePos, activeCamera);
            
            // Reset highlight on all bags
            resetBagHighlights();
            
            // If using third person camera, check if we're close enough to any bag
            if (cameraMode === "thirdPerson" && characterTilt) {
                const characterPos = new THREE.Vector3();
                characterTilt.getWorldPosition(characterPos);
                
                // Create an array of all bags
                const bags = [];
                if (groundBag1 && !attachedBags.some(b => b.mesh === groundBag1)) bags.push(groundBag1);
                if (groundBag2 && !attachedBags.some(b => b.mesh === groundBag2)) bags.push(groundBag2);
                if (groundBag3 && !attachedBags.some(b => b.mesh === groundBag3)) bags.push(groundBag3);
                if (groundBag4 && !attachedBags.some(b => b.mesh === groundBag4)) bags.push(groundBag4);
                if (carBag1 && !attachedBags.some(b => b.mesh === carBag1)) bags.push(carBag1);
                if (carBag2 && !attachedBags.some(b => b.mesh === carBag2)) bags.push(carBag2);
                if (carBag3 && !attachedBags.some(b => b.mesh === carBag3)) bags.push(carBag3);
                if (carBag4 && !attachedBags.some(b => b.mesh === carBag4)) bags.push(carBag4);
                
                // Check distance to each bag
                for (const bag of bags) {
                    const bagPos = new THREE.Vector3();
                    bag.getWorldPosition(bagPos);
                    
                    // Calculate distance
                    const distance = characterPos.distanceTo(bagPos);
                    
                    // If close enough (within 2.5 units)
                    if (distance < 2.5) {
                        // Add highlight to this bag
                        highlightBag(bag);
                        
                        // Determine if it's a ground bag or car bag
                        if (bag === groundBag1 || bag === groundBag2) {
                            return { bag, isGroundBag: true };
                        } else {
                            return { bag, isGroundBag: false };
                        }
                    }
                }
            } else {
                // Regular raycast for orbit camera mode
                // Create an array of all bags
                const bags = [];
                if (groundBag1 && !attachedBags.some(b => b.mesh === groundBag1)) bags.push(groundBag1);
                if (groundBag2 && !attachedBags.some(b => b.mesh === groundBag2)) bags.push(groundBag2);
                if (carBag1 && !attachedBags.some(b => b.mesh === carBag1)) bags.push(carBag1);
                if (carBag2 && !attachedBags.some(b => b.mesh === carBag2)) bags.push(carBag2);
                
                // Find all meshes in the bags
                const bagMeshes = [];
                bags.forEach(bag => {
                    bag.traverse(child => {
                        if (child.isMesh) {
                            bagMeshes.push({
                                mesh: child,
                                bag: bag
                            });
                        }
                    });
                });
                
                // Check for intersections
                const intersects = raycaster.intersectObjects(
                    bagMeshes.map(item => item.mesh),
                    true
                );
                
                if (intersects.length > 0) {
                    // Find which bag this mesh belongs to
                    const hitMesh = intersects[0].object;
                    const bagInfo = bagMeshes.find(item => item.mesh === hitMesh || item.mesh.isAncestorOf(hitMesh));
                    
                    if (bagInfo) {
                        const bag = bagInfo.bag;
                        
                        // Add highlight to this bag
                        highlightBag(bag);
                        
                        // Determine if it's a ground bag or car bag
                        if (bag === groundBag1 || bag === groundBag2) {
                            return { bag, isGroundBag: true };
                        } else {
                            return { bag, isGroundBag: false };
                        }
                    }
                }
            }
            
            return null;
        }
        
        // Function to highlight a bag by changing its material
        function highlightBag(bag) {
            bag.traverse(node => {
                if (node.isMesh && node.material) {
                    // Store original emission if not already stored
                    if (!node.userData.originalEmissive) {
                        node.userData.originalEmissive = node.material.emissive ? 
                            node.material.emissive.clone() : new THREE.Color(0, 0, 0);
                    }
                    
                    // Add emission for highlight
                    if (node.material.emissive) {
                        node.material.emissive.set(0, 0.5, 0);
                    }
                }
            });
        }
        
        // Function to reset all bag highlights
        function resetBagHighlights() {
            const allBags = [groundBag1, groundBag2, carBag1, carBag2];
            
            allBags.forEach(bag => {
                if (!bag) return;
                
                bag.traverse(node => {
                    if (node.isMesh && node.material && node.userData.originalEmissive) {
                        if (node.material.emissive) {
                            node.material.emissive.copy(node.userData.originalEmissive);
                        }
                    }
                });
            });
        }
        
        // Interactive pickup function for touch/click
        function attemptPickupInteraction() {
            // Don't allow pickups during pickup animations
            if (currentUpperBodyAnimation.startsWith('pickup')) {
                updateDebug("Cannot pickup: already in pickup animation");
                showPickupFeedback("Wait for pickup to finish");
                return false;
            }
            
            const bagInView = findInteractableBagInViewDirection();
            
            if (bagInView) {
                updateDebug(`Found bag to pick up: ${bagInView.isGroundBag ? 'ground' : 'car'} bag`);
                showPickupFeedback(bagInView.isGroundBag ? "Picking up bag..." : "Grabbing from car...");
                
                if (bagInView.isGroundBag) {
                    // Ground pickup
                    setUpperBodyAnimation('pickup_low');
                    
                    setTimeout(() => {
                        if (rightHand && bagInView.bag && !attachedBags.some(b => b.mesh === bagInView.bag)) {
                            attachBagToHand(bagInView.bag, rightHand);
                        } else {
                            showPickupFeedback("Cannot pick up this bag");
                        }
                    }, 500);
                } else {
                    // Car pickup
                    setUpperBodyAnimation('pickup_high');
                    
                    setTimeout(() => {
                        if (leftHand && bagInView.bag && !attachedBags.some(b => b.mesh === bagInView.bag)) {
                            attachBagToHand(bagInView.bag, leftHand);
                        } else {
                            showPickupFeedback("Cannot pick up this bag");
                        }
                    }, 500);
                }
                return true;
            } else {
                updateDebug("No bag found to pick up");
                showPickupFeedback("No bags in range");
            }
            
            return false;
        }

        // Setup a simple debug display
        const debugEl = document.getElementById('debug');
        function updateDebug(message) {
            const debugEl = document.getElementById('debug');
            if (!debugEl) return;
            
            // Add message to debug log
            const now = new Date().toLocaleTimeString();
            debugEl.innerHTML = `[${now}] ${message}<br>` + debugEl.innerHTML.split('<br>').slice(0, 10).join('<br>');
        }

        // Add keyboard shortcut to toggle development UI
        document.addEventListener('keydown', function(e) {
            // Press D key to toggle development controls
            if (e.key.toLowerCase() === 'd' && e.ctrlKey) {
                const elements = [
                    document.getElementById('controls'),
                    document.getElementById('balanceUI'),
                    document.getElementById('pickupControls'),
                    document.getElementById('debug')
                ];
                
                elements.forEach(el => {
                    if (el) {
                        el.style.display = el.style.display === 'none' ? 'block' : 'none';
                    }
                });
            }
        });

        // Add close button event listener
        document.getElementById('closeHelpBtn').addEventListener('click', function() {
            document.getElementById('helpOverlay').style.display = 'none';
        });

        // Add Escape key to close overlays
        window.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                // Close help overlay
                document.getElementById('helpOverlay').style.display = 'none';
            }
        });

        // Highlight pickup button when bags are in range
        function updatePickupButtonHighlight() {
            const bagInView = findInteractableBagInViewDirection();
            const interactBtn = document.getElementById('interactButton');
            const rangeIndicator = document.getElementById('bagInRangeIndicator');
            
            if (bagInView && interactBtn) {
                interactBtn.classList.add('highlight');
                interactBtn.textContent = bagInView.isGroundBag ? 'Pickup' : 'Grab';
                
                // Show range indicator
                if (rangeIndicator) {
                    rangeIndicator.style.opacity = '1';
                }
            } else if (interactBtn) {
                interactBtn.classList.remove('highlight');
                interactBtn.textContent = 'Pick';
                
                // Hide range indicator
                if (rangeIndicator) {
                    rangeIndicator.style.opacity = '0';
                }
            }
        }

        // Collision detection variables
        let collisionObjects = [];
        
        // Function to set up collision detection
        function setupCollisionDetection() {
            // Add collision objects (house, car, environment objects)
            scene.traverse(function(object) {
                // Add objects that should block movement to collision list
                if (object.userData && object.userData.isCollider) {
                    collisionObjects.push(object);
                }
                // Add house, car and other large objects that should be collidable
                else if (object.name && (
                    object.name.includes('House') || 
                    object.name.includes('Car') ||
                    object.name.includes('Tree') ||
                    object.name.includes('Rocks'))) {
                    collisionObjects.push(object);
                    // For debugging
                    updateDebug(`Added collision object: ${object.name}`);
                }
            });
        }
        
        // Function to check if movement would cause a collision
        function checkCollision(position, moveDirection, radius = 0.5) {
            // Create a ray from the character position in the direction of movement
            const raycaster = new THREE.Raycaster(
                position.clone(), 
                moveDirection.clone().normalize(),
                0,
                radius + moveDirection.length()
            );
            
            // Check for collisions with objects
            const intersects = raycaster.intersectObjects(collisionObjects, true);
            
            if (intersects.length > 0) {
                // Check if we're close enough to consider this a collision
                if (intersects[0].distance < radius) {
                    return true;
                }
            }
            
            return false;
        }
        
        // Function to handle step climbing
        function handleStepClimbing(position, moveDirection) {
            // Only check step climbing if we're moving forward enough
            if (moveDirection.length() < 0.01) return false;
            
            // Cast a ray downward from in front of the character to check for steps
            const stepCheckPosition = position.clone().add(
                moveDirection.clone().normalize().multiplyScalar(0.5)
            );
            stepCheckPosition.y += 0.5; // Raise the starting point a bit
            
            const raycaster = new THREE.Raycaster(
                stepCheckPosition,
                new THREE.Vector3(0, -1, 0), // Cast ray downward
                0,
                1.0 // Maximum step height
            );
            
            const intersects = raycaster.intersectObjects(collisionObjects, true);
            
            if (intersects.length > 0) {
                // This is a step we can climb - adjust y position
                position.y = intersects[0].point.y;
                updateDebug(`Climbing step: new Y = ${position.y.toFixed(2)}`);
                return true;
            }
            
            return false;
        }

        // Update debug display
        function updateDebug(message) {
            const debugEl = document.getElementById('debug');
            if (!debugEl) return;
            
            // Add message to debug log
            const now = new Date().toLocaleTimeString();
            debugEl.innerHTML = `[${now}] ${message}<br>` + debugEl.innerHTML.split('<br>').slice(0, 10).join('<br>');
        }

        // Hide debug elements by default (but leave them available for development)
        function hideDebugElements() {
            // Debug elements to hide by default
            const debugElements = [
                'controls',
                'debug',
                'pickupControls'
            ];
            
            // Hide debug elements
            debugElements.forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    element.style.display = 'none';
                }
            });
        }
        
        // Optimize UI for PC or mobile
        function optimizeUIForDevice() {
            // Get necessary elements
            const carryInfo = document.getElementById('carryInfo');
            const balanceUI = document.getElementById('balanceUI');
            const touchControls = document.getElementById('touchControls');
            
            if (isUsingTouch) {
                // Mobile-specific UI adjustments
                if (touchControls) touchControls.style.display = 'block';
                
                // Move balance UI to a better position for mobile
                if (balanceUI) {
                    balanceUI.style.bottom = '150px';
                    balanceUI.style.right = '10px';
                    balanceUI.style.maxWidth = '150px';
                }
                
                // Make carry info more compact
                if (carryInfo) {
                    carryInfo.style.top = '10px';
                    carryInfo.style.left = '10px';
                    carryInfo.style.padding = '5px';
                    carryInfo.style.fontSize = '14px';
                }
            } else {
                // PC-specific UI adjustments
                if (touchControls) touchControls.style.display = 'none';
                
                // Show minimal UI by default on PC
                if (balanceUI) {
                    balanceUI.style.bottom = '10px';
                    balanceUI.style.right = '10px';
                    balanceUI.style.width = '200px';
                }
                
                // Make carry info visible at top-left
                if (carryInfo) {
                    carryInfo.style.display = 'block';
                    carryInfo.style.top = '10px';
                    carryInfo.style.left = '10px';
                    carryInfo.style.padding = '10px';
                    carryInfo.style.fontSize = '16px';
                }
            }
            
            // Hide balance UI initially (will show when carrying bags)
            if (balanceUI) balanceUI.style.display = 'none';
        }
    </script>
</body>
</html> 