<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>One Trip - Model Scale Test</title>
    <style>
        body { margin: 0; overflow: hidden; background: #111; }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            color: white;
            text-align: center;
            padding: 10px;
            font-family: Arial, sans-serif;
            z-index: 100;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="info">Loading models...</div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.147.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.147.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.147.0/examples/js/loaders/GLTFLoader.js"></script>

    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        
        // Camera setup - intentionally farther back
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.set(0, 10, 30); // Much further back to see everything
        
        // Renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);
        
        // Controls for testing
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.target.set(0, 2, 0);
        controls.update();
        
        // Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(5, 10, 5);
        directionalLight.castShadow = true;
        scene.add(directionalLight);
        
        // Ground
        const groundGeometry = new THREE.PlaneGeometry(100, 100);
        const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x7CFC00 });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);
        
        // Grid helper
        const gridHelper = new THREE.GridHelper(100, 100);
        scene.add(gridHelper);
        
        // Create text labels for each model
        function createLabel(text, position) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 64;
            
            context.fillStyle = 'rgba(0,0,0,0.7)';
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            context.font = '24px Arial';
            context.fillStyle = 'white';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(text, canvas.width/2, canvas.height/2);
            
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.MeshBasicMaterial({
                map: texture,
                transparent: true,
                side: THREE.DoubleSide
            });
            
            const geometry = new THREE.PlaneGeometry(5, 1.25);
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(position.x, position.y + 5, position.z);
            mesh.lookAt(camera.position);
            
            scene.add(mesh);
            return mesh;
        }

        // Models to load - with preset scales that should work better
        const models = [
            { name: 'Character', file: './onetrip_maincharacter.glb', position: [0, 0, 0], scale: 0.5 },
            { name: 'Bag 1', file: './newbag.glb', position: [5, 0, 0], scale: 0.5 },
            { name: 'Bag 2', file: './bag2.glb', position: [7, 0, 0], scale: 0.5 },
            { name: 'House', file: './house.glb', position: [15, 0, 0], scale: 0.5 },
            { name: 'Car', file: './car.glb', position: [-10, 0, 0], scale: 0.5 },
            { name: 'Tree', file: './tree.glb', position: [-5, 0, 5], scale: 0.5 },
            { name: 'Rocks', file: './rocks.glb', position: [10, 0, 5], scale: 0.5 },
            { name: 'Leaves', file: './leaves.glb', position: [0, 0, 5], scale: 0.5 }
        ];

        // Load models
        const loader = new THREE.GLTFLoader();
        let loadedCount = 0;
        let characterModel;
        let mixer;
        
        models.forEach(model => {
            // Create label for this model
            const labelMesh = createLabel(model.name, {
                x: model.position[0],
                y: model.position[1],
                z: model.position[2]
            });
            
            loader.load(
                model.file,
                (gltf) => {
                    const modelObj = gltf.scene;
                    
                    // Set smaller scale initially
                    modelObj.scale.set(model.scale, model.scale, model.scale);
                    modelObj.position.set(...model.position);
                    
                    // Enable shadows
                    modelObj.traverse(node => {
                        if (node.isMesh) {
                            node.castShadow = true;
                            node.receiveShadow = true;
                        }
                    });
                    
                    scene.add(modelObj);
                    
                    // Store character model and set up animations
                    if (model.name === 'Character') {
                        characterModel = modelObj;
                        
                        // Create animation mixer
                        mixer = new THREE.AnimationMixer(modelObj);
                        
                        // Find and play walking animation by default
                        const walkAnim = gltf.animations.find(anim => anim.name === 'walk');
                        if (walkAnim) {
                            const action = mixer.clipAction(walkAnim);
                            action.play();
                        } else if (gltf.animations.length > 0) {
                            // If no walk animation, play the first one
                            const action = mixer.clipAction(gltf.animations[0]);
                            action.play();
                        }
                        
                        // Log all animations
                        console.log('Available animations:', 
                            gltf.animations.map(a => a.name));
                    }
                    
                    // Update loaded count
                    loadedCount++;
                    document.getElementById('info').textContent = 
                        `Loaded ${loadedCount}/${models.length} models`;
                    
                    if (loadedCount === models.length) {
                        document.getElementById('info').textContent = 
                            `All models loaded - Orbit with mouse to compare scales (suggested character scale: 0.5)`;
                    }
                },
                (xhr) => {
                    console.log(`${model.name} ${Math.round(xhr.loaded / xhr.total * 100)}% loaded`);
                },
                (error) => {
                    console.error(`Error loading ${model.name}:`, error);
                    loadedCount++;
                    document.getElementById('info').textContent += 
                        `\nError loading ${model.name}`;
                }
            );
        });
        
        // Animation loop
        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            
            const delta = clock.getDelta();
            
            // Update character animations
            if (mixer) mixer.update(delta);
            
            // Update label orientations
            scene.children.forEach(child => {
                if (child.material && child.material.map && 
                    child.material.map.isCanvasTexture) {
                    child.lookAt(camera.position);
                }
            });
            
            renderer.render(scene, camera);
        }
        animate();
        
        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Log key commands
        console.log("Camera Controls: Left mouse button to rotate, middle mouse to pan, scroll to zoom");
    </script>
</body>
</html> 