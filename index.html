<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>One Trip</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: manipulation;
        }
        
        body { 
            overflow: hidden; 
            background: #111;
            font-family: 'Segoe UI', Arial, sans-serif;
            color: white;
            -webkit-tap-highlight-color: transparent;
        }
        
        #game-container { 
            position: absolute;
            top: 0;
            left: 0;
            width: 100%; 
            height: 100%;
        }
        #ui-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        #loading-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #fdbb2d);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            transition: opacity 0.5s;
        }
        #loading-bar {
            width: 300px;
            height: 6px;
            background: rgba(255,255,255,0.3);
            border-radius: 3px;
            margin-top: 40px;
            overflow: hidden;
        }
        #loading-progress {
            height: 100%;
            width: 0%;
            background: white;
            border-radius: 3px;
            transition: width 0.3s;
        }
        #loading-text {
            margin-top: 10px;
            font-size: 14px;
            opacity: 0.8;
        }
        #balance-meter {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            height: 10px;
            background: rgba(0,0,0,0.5);
            border-radius: 5px;
            overflow: hidden;
            opacity: 0;
            transition: opacity 0.5s;
        }
        #balance-indicator {
            position: absolute;
            top: 0;
            left: 50%;
            width: 6px;
            height: 100%;
            background: white;
            transform: translateX(-50%);
            transition: left 0.1s;
        }
        #balance-zone {
            position: absolute;
            top: 0;
            left: 40%;
            width: 20%;
            height: 100%;
            background: rgba(76, 175, 80, 0.3);
        }
        #bag-counter {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.5);
            color: white;
            padding: 8px 15px;
            border-radius: 20px;
            opacity: 0;
            transition: opacity 0.5s;
        }
        #item-counter {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.5);
            color: white;
            padding: 10px 15px;
            border-radius: 5px;
            display: none;
        }
        #controls {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.5);
            color: white;
            padding: 10px 15px;
            border-radius: 5px;
            pointer-events: none;
        }
        .win-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 32px;
            z-index: 1000;
            pointer-events: auto;
        }
        .win-screen button {
            padding: 10px 20px;
            margin-top: 20px;
            font-size: 18px;
            cursor: pointer;
            background: #4CAF50;
            border: none;
            border-radius: 5px;
            color: white;
        }
        #floating-text {
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px 15px;
            border-radius: 5px;
            font-weight: bold;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 1000;
        }
        
        #tooltip {
            position: absolute;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 14px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 100;
            white-space: nowrap;
        }
        
        .virtual-joystick {
            position: absolute;
            bottom: 80px;
            left: 80px;
            width: 120px;
            height: 120px;
            background: rgba(255,255,255,0.15);
            border-radius: 60px;
            display: none;
            touch-action: none;
        }
        
        .joystick-knob {
            position: absolute;
            width: 50px;
            height: 50px;
            background: rgba(255,255,255,0.5);
            border-radius: 25px;
            top: 35px;
            left: 35px;
            transform: translate(-50%, -50%);
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }
        
        .action-buttons {
            position: absolute;
            bottom: 80px;
            right: 40px;
            display: none;
        }
        
        .action-button {
            width: 60px;
            height: 60px;
            background: rgba(255,255,255,0.2);
            border-radius: 30px;
            margin: 0 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            touch-action: manipulation;
            user-select: none;
        }
        
        .action-button:active {
            background: rgba(255,255,255,0.4);
        }
        
        .pickup-button {
            background: rgba(76, 175, 80, 0.6);
        }
        
        .level-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s;
        }
        
        .level-title {
            font-size: 36px;
            margin-bottom: 20px;
        }
        
        .level-description {
            font-size: 18px;
            max-width: 80%;
            text-align: center;
            opacity: 0.8;
            margin-bottom: 40px;
        }
        
        .start-button {
            padding: 12px 30px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 25px;
            font-size: 18px;
            cursor: pointer;
            outline: none;
        }
        
        @media (max-width: 768px) {
            .virtual-joystick, .action-buttons {
                display: block;
            }
            
            #balance-meter {
                bottom: 170px;
            }
        }
    </style>
</head>
<body>
    <div id="game-container"></div>
    
    <div id="ui-container">
        <div id="loading-screen">
            <div id="title-logo">
                <h1 style="font-size: 48px; margin-bottom: 10px;">ONE TRIP</h1>
                <p style="font-size: 18px; opacity: 0.8; text-align: center;">Don't drop your groceries!</p>
            </div>
            <div id="loading-bar"><div id="loading-progress"></div></div>
            <div id="loading-text">Loading assets...</div>
        </div>
        
        <div id="balance-meter">
            <div id="balance-zone"></div>
            <div id="balance-indicator"></div>
        </div>
        
        <div id="bag-counter">Bags: 0/5</div>
        
        <div id="tooltip"></div>
        <div id="floating-text"></div>
        
        <div class="virtual-joystick" id="joystick">
            <div class="joystick-knob" id="joystick-knob"></div>
        </div>
        
        <div class="action-buttons" id="action-buttons">
            <div class="action-button pickup-button" id="pickup-button">GRAB</div>
            <div class="action-button" id="balance-left-button">←</div>
            <div class="action-button" id="balance-right-button">→</div>
        </div>
        
        <div class="level-screen" id="level-screen">
            <h2 class="level-title" id="level-title">Level 1: The Driveway</h2>
            <p class="level-description" id="level-description">Bring all the groceries from your car to your house in one trip!</p>
            <button class="start-button" id="start-level-button">START</button>
        </div>
    </div>

    <!-- Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.147.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.147.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.147.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.147.0/examples/js/loaders/DRACOLoader.js"></script>
    
    <script>
        class OneTripGame {
            constructor() {
                // Check for mobile device
                this.isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                
                // Asset paths
                this.assets = {
                    character: './onetrip_maincharacter.glb',
                    bag1: './newbag.glb',
                    bag2: './bag2.glb',
                    car: './car.glb',
                    house: './house.glb',
                    // New environmental assets
                    tree: './tree.glb',
                    rocks: './rocks.glb',
                    leaves: './leaves.glb'
                };
                
                // Game state
                this.state = {
                    isLoading: true,
                    assetsLoaded: 0,
                    totalAssets: Object.keys(this.assets).length + 2, // +2 for textures
                    isPlaying: false,
                    bagsCarried: 0,
                    maxBags: 5,
                    balance: 0.5, // 0 = fall left, 1 = fall right, 0.5 = balanced
                    balanceStability: 1.0, // 0 = very unstable, 1 = stable
                    gameOver: false,
                    isStumbling: false,
                    currentLevel: 1,
                    pickupCooldown: false
                };
                
                // Animation states
                this.animations = {
                    current: 'tpose',
                    mixer: null,
                    clips: {},
                    actions: {}
                };
                
                // Bag attachment points
                this.attachPoints = [];
                
                // Available bags
                this.bags = [];
                this.availableBags = [];
                
                // Obstacles
                this.obstacles = [];
                
                // Timekeeping
                this.clock = new THREE.Clock();
                this.deltaTime = 0;
                
                // Input state
                this.input = {
                    moveX: 0,
                    moveZ: 0,
                    isRunning: false,
                    isPickingUp: false,
                    balanceLeft: false,
                    balanceRight: false
                };
                
                // Step sound timing
                this.stepSoundTimer = 0;
                
                // Set up sound effects
                this.setupSounds();
                
                // Initialize game
                this.init();
                
                // Add asset loading timeout for fallback
                setTimeout(() => {
                    if (this.state.isLoading) {
                        console.log("Assets taking too long to load - creating placeholders");
                        this.handleMissingAssets();
                    }
                }, 10000);
            }
            
            init() {
                // Set up scene
                this.setupScene();
                
                // Set up input
                this.setupInput();
                
                // Set up UI
                this.setupUI();
                
                // Load assets
                this.loadAssets();
                
                // Start animation loop
                this.animate();
                
                // Add fallback for asset loading
                setTimeout(() => {
                    if (this.state.isLoading) {
                        console.log("Assets taking too long to load - creating placeholders");
                        this.createPlaceholders();
                    }
                }, 15000);
            }
            
            setupScene() {
                // Create scene
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x87CEEB); // Sky blue
                
                // Create camera
                this.camera = new THREE.PerspectiveCamera(
                    70, 
                    window.innerWidth / window.innerHeight, 
                    0.1, 
                    1000
                );
                this.camera.position.set(0, 3, 8);
                
                // Create renderer
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                document.getElementById('game-container').appendChild(this.renderer.domElement);
                
                // Add lights
                this.addLights();
                
                // Add ground
                this.addGround();
                
                // Handle window resize
                window.addEventListener('resize', () => this.onWindowResize());
                
                // Add temporary controls for development
                this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
                this.controls.target.set(0, 1, 0);
                this.controls.update();
            }
            
            addLights() {
                // Main directional light (sun)
                this.directionalLight = new THREE.DirectionalLight(0xFFFFFF, 1);
                this.directionalLight.position.set(10, 10, 10);
                this.directionalLight.castShadow = true;
                
                // Optimize shadow quality
                this.directionalLight.shadow.mapSize.width = 2048;
                this.directionalLight.shadow.mapSize.height = 2048;
                this.directionalLight.shadow.camera.near = 0.5;
                this.directionalLight.shadow.camera.far = 50;
                this.directionalLight.shadow.camera.left = -20;
                this.directionalLight.shadow.camera.right = 20;
                this.directionalLight.shadow.camera.top = 20;
                this.directionalLight.shadow.camera.bottom = -20;
                
                this.scene.add(this.directionalLight);
                
                // Ambient light
                this.ambientLight = new THREE.AmbientLight(0x404040, 0.5);
                this.scene.add(this.ambientLight);
                
                // Hemisphere light
                this.hemiLight = new THREE.HemisphereLight(0xB1E1FF, 0x444444, 0.6);
                this.scene.add(this.hemiLight);
            }
            
            addGround() {
                // Create ground plane
                const groundGeometry = new THREE.PlaneGeometry(100, 100);
                const groundMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x7CFC00, 
                    roughness: 0.8, 
                    metalness: 0.1 
                });
                this.ground = new THREE.Mesh(groundGeometry, groundMaterial);
                this.ground.rotation.x = -Math.PI / 2;
                this.ground.receiveShadow = true;
                this.scene.add(this.ground);
                
                // Add driveway path
                const pathGeometry = new THREE.PlaneGeometry(4, 30);
                const pathMaterial = new THREE.MeshStandardMaterial({
                    color: 0xBDBDBD,
                    roughness: 0.9,
                    metalness: 0.0
                });
                this.path = new THREE.Mesh(pathGeometry, pathMaterial);
                this.path.rotation.x = -Math.PI / 2;
                this.path.position.y = 0.01; // Slightly above ground to prevent z-fighting
                
                // Position the path to connect car and house
                const carPos = new THREE.Vector3(-15, 0, 0);
                const housePos = new THREE.Vector3(15, 0, 0);
                const midpoint = new THREE.Vector3().addVectors(carPos, housePos).multiplyScalar(0.5);
                
                this.path.position.x = midpoint.x;
                this.path.position.z = midpoint.z;
                
                this.path.receiveShadow = true;
                this.scene.add(this.path);
                
                // Load ground textures
                this.loadGroundTextures();
            }
            
            loadGroundTextures() {
                // Create a texture loader
                this.textureLoader = new THREE.TextureLoader();
                
                // Load grass texture
                this.textureLoader.load(
                    'https://threejsfundamentals.org/threejs/resources/images/grass.jpg',
                    (texture) => {
                        this.grassTexture = texture;
                        this.grassTexture.wrapS = THREE.RepeatWrapping;
                        this.grassTexture.wrapT = THREE.RepeatWrapping;
                        this.grassTexture.repeat.set(20, 20);
                        this.updateLoadingProgress();
                        
                        // Update ground texture
                        this.updateGroundTexture();
                    },
                    undefined,
                    (error) => {
                        console.error('Error loading grass texture:', error);
                        this.updateLoadingProgress();
                    }
                );
                
                // Load driveway texture
                this.textureLoader.load(
                    'https://threejs.org/examples/textures/granite.jpg',
                    (texture) => {
                        this.drivewayTexture = texture;
                        this.drivewayTexture.wrapS = THREE.RepeatWrapping;
                        this.drivewayTexture.wrapT = THREE.RepeatWrapping;
                        this.drivewayTexture.repeat.set(2, 10);
                        this.updateLoadingProgress();
                        
                        // Update driveway texture
                        this.updateDrivewayTexture();
                    },
                    undefined,
                    (error) => {
                        console.error('Error loading driveway texture:', error);
                        this.updateLoadingProgress();
                    }
                );
            }
            
            updateGroundTexture() {
                if (this.ground && this.grassTexture) {
                    this.ground.material.map = this.grassTexture;
                    this.ground.material.needsUpdate = true;
                }
            }
            
            updateDrivewayTexture() {
                if (this.path && this.drivewayTexture) {
                    this.path.material.map = this.drivewayTexture;
                    this.path.material.color.set(0xffffff); // Reset color to show texture
                    this.path.material.needsUpdate = true;
                }
            }
            
            onWindowResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }
            
            setupInput() {
                // Keyboard input
                this.keys = {};
                window.addEventListener('keydown', (e) => {
                    this.keys[e.code] = true;
                });
                
                window.addEventListener('keyup', (e) => {
                    this.keys[e.code] = false;
                });
                
                // Touch input for mobile
                if (this.isMobile) {
                    this.setupMobileControls();
                }
            }
            
            loadAssets() {
                // Set up loaders
                this.gltfLoader = new THREE.GLTFLoader();
                
                // Optional: Set up Draco loader for compressed models
                const dracoLoader = new THREE.DRACOLoader();
                dracoLoader.setDecoderPath('https://www.gstatic.com/draco/v1/decoders/');
                this.gltfLoader.setDRACOLoader(dracoLoader);
                
                // Load all assets
                this.loadCharacter();
                this.loadCar();
                this.loadHouse();
                this.loadBags();
                
                // Load environment assets
                this.loadEnvironmentAssets();
            }
            
            loadEnvironmentAssets() {
                // Load tree model
                this.gltfLoader.load(
                    this.assets.tree,
                    (gltf) => {
                        this.treeTemplate = gltf.scene;
                        this.updateLoadingProgress();
                        
                        // Create trees once loaded
                        if (this.treeTemplate) {
                            this.createTrees();
                        }
                    },
                    (xhr) => {
                        console.log(`Tree loading: ${Math.round(xhr.loaded / xhr.total * 100)}%`);
                    },
                    (error) => {
                        console.error('Error loading tree:', error);
                        this.updateLoadingProgress();
                    }
                );
                
                // Load rocks model
                this.gltfLoader.load(
                    this.assets.rocks,
                    (gltf) => {
                        this.rocksTemplate = gltf.scene;
                        this.updateLoadingProgress();
                        
                        // Create rocks once loaded
                        if (this.rocksTemplate) {
                            this.createRocks();
                        }
                    },
                    (xhr) => {
                        console.log(`Rocks loading: ${Math.round(xhr.loaded / xhr.total * 100)}%`);
                    },
                    (error) => {
                        console.error('Error loading rocks:', error);
                        this.updateLoadingProgress();
                    }
                );
                
                // Load leaves model
                this.gltfLoader.load(
                    this.assets.leaves,
                    (gltf) => {
                        this.leavesTemplate = gltf.scene;
                        this.updateLoadingProgress();
                        
                        // Create leaf piles once loaded
                        if (this.leavesTemplate) {
                            this.createLeafPiles();
                        }
                    },
                    (xhr) => {
                        console.log(`Leaves loading: ${Math.round(xhr.loaded / xhr.total * 100)}%`);
                    },
                    (error) => {
                        console.error('Error loading leaves:', error);
                        this.updateLoadingProgress();
                    }
                );
            }
            
            loadCharacter() {
                this.gltfLoader.load(
                    this.assets.character,
                    (gltf) => {
                        console.log('Character loaded successfully');
                        
                        // Add character to scene
                        this.character = gltf.scene;
                        this.character.position.set(-10, 0, 0);
                        this.character.castShadow = true;
                        this.character.receiveShadow = true;
                        this.scene.add(this.character);
                        
                        // Enable shadows for all meshes
                        this.character.traverse((node) => {
                            if (node.isMesh) {
                                node.castShadow = true;
                                node.receiveShadow = true;
                            }
                        });
                        
                        // Set up animations
                        this.setupAnimations(gltf);
                        
                        // Create attachment points for bags
                        this.createAttachmentPoints();
                        
                        // Update loading progress
                        this.updateLoadingProgress();
                    },
                    (xhr) => {
                        console.log(`Character loading: ${Math.round(xhr.loaded / xhr.total * 100)}%`);
                    },
                    (error) => {
                        console.error('Error loading character:', error);
                        this.updateLoadingProgress();
                    }
                );
            }
            
            setupAnimations(gltf) {
                if (!gltf.animations || gltf.animations.length === 0) {
                    console.log('No animations found in model');
                    return;
                }
                
                // Create animation mixer
                this.animations.mixer = new THREE.AnimationMixer(this.character);
                
                // Get all animation clips
                const clips = gltf.animations;
                
                // Process default animations or create placeholders
                const requiredAnimations = [
                    'idle', 'walk', 'run', 'pickup', 'carry_idle', 
                    'carry_walk', 'carry_run', 'stumble', 'fall'
                ];
                
                // Find and set up animations from the model
                clips.forEach(clip => {
                    // Clean up animation name (remove namespace)
                    const animName = clip.name.split('|').pop().toLowerCase();
                    console.log(`Found animation: ${animName}`);
                    
                    // Store and create action
                    this.animations.clips[animName] = clip;
                    const action = this.animations.mixer.clipAction(clip);
                    this.animations.actions[animName] = action;
                });
                
                // Set default animation
                this.playAnimation('idle');
            }
            
            playAnimation(name, transitionTime = 0.2) {
                if (!this.animations.mixer) return;
                
                // If animation doesn't exist, use a fallback
                if (!this.animations.actions[name]) {
                    console.log(`Animation ${name} not found, using fallback`);
                    
                    // Use a similar animation as fallback
                    if (name.includes('carry')) {
                        name = Object.keys(this.animations.actions).find(a => a.includes('carry')) || 'idle';
                    } else {
                        name = 'idle';
                    }
                    
                    // If still not found, do nothing
                    if (!this.animations.actions[name]) {
                        console.log('No fallback animation found');
                        return;
                    }
                }
                
                // Skip if already playing this animation
                if (this.animations.current === name) return;
                
                // Crossfade to new animation
                const action = this.animations.actions[name];
                action.reset();
                action.setEffectiveTimeScale(1);
                action.setEffectiveWeight(1);
                action.fadeIn(transitionTime);
                
                // Fade out current animation if exists
                if (this.animations.current && this.animations.actions[this.animations.current]) {
                    this.animations.actions[this.animations.current].fadeOut(transitionTime);
                }
                
                this.animations.current = name;
            }
            
            loadCar() {
                this.gltfLoader.load(
                    this.assets.car,
                    (gltf) => {
                        // Add car to scene
                        this.car = gltf.scene;
                        this.car.position.set(-15, 0, 0);
                        this.car.rotation.y = Math.PI / 2; // Rotate to face the house
                        this.car.castShadow = true;
                        this.car.receiveShadow = true;
                        this.scene.add(this.car);
                        
                        // Enable shadows for all meshes
                        this.car.traverse((node) => {
                            if (node.isMesh) {
                                node.castShadow = true;
                                node.receiveShadow = true;
                            }
                        });
                        
                        // Update loading progress
                        this.updateLoadingProgress();
                    },
                    (xhr) => {
                        console.log(`Car loading: ${Math.round(xhr.loaded / xhr.total * 100)}%`);
                    },
                    (error) => {
                        console.error('Error loading car:', error);
                        this.updateLoadingProgress();
                    }
                );
            }
            
            loadHouse() {
                this.gltfLoader.load(
                    this.assets.house,
                    (gltf) => {
                        // Add house to scene
                        this.house = gltf.scene;
                        this.house.position.set(15, 0, 0);
                        this.house.castShadow = true;
                        this.house.receiveShadow = true;
                        this.scene.add(this.house);
                        
                        // Enable shadows for all meshes
                        this.house.traverse((node) => {
                            if (node.isMesh) {
                                node.castShadow = true;
                                node.receiveShadow = true;
                            }
                        });
                        
                        // Update loading progress
                        this.updateLoadingProgress();
                    },
                    (xhr) => {
                        console.log(`House loading: ${Math.round(xhr.loaded / xhr.total * 100)}%`);
                    },
                    (error) => {
                        console.error('Error loading house:', error);
                        this.updateLoadingProgress();
                    }
                );
            }
            
            loadBags() {
                // Load multiple bag types
                const bagTypes = ['bag1', 'bag2'];
                
                bagTypes.forEach((bagType) => {
                    this.gltfLoader.load(
                        this.assets[bagType],
                        (gltf) => {
                            // Create template for bag
                            const bagTemplate = gltf.scene.clone();
                            
                            // Set up template properties
                            bagTemplate.traverse(node => {
                                if (node.isMesh) {
                                    node.castShadow = true;
                                    node.receiveShadow = true;
                                }
                            });
                            
                            if (bagType === 'bag1') {
                                this.bag1Template = bagTemplate;
                            } else {
                                this.bag2Template = bagTemplate;
                            }
                            
                            // Create bags once all templates are loaded
                            if (this.bag1Template && this.bag2Template) {
                                this.createBags();
                            }
                            
                            // Update loading progress
                            this.updateLoadingProgress();
                        },
                        (xhr) => {
                            console.log(`${bagType} loading: ${Math.round(xhr.loaded / xhr.total * 100)}%`);
                        },
                        (error) => {
                            console.error(`Error loading ${bagType}:`, error);
                            this.updateLoadingProgress();
                        }
                    );
                });
            }
            
            createBags() {
                if (!this.bag1Template || !this.bag2Template) return;
                
                // Create bags around the car
                const bagPositions = [
                    { x: -14, z: 2, type: 'bag1', rotation: 0 },
                    { x: -16, z: 1, type: 'bag2', rotation: Math.PI/4 },
                    { x: -14, z: -1, type: 'bag1', rotation: -Math.PI/6 },
                    { x: -15, z: -2, type: 'bag2', rotation: Math.PI/2 },
                    { x: -16, z: -1, type: 'bag1', rotation: -Math.PI/3 }
                ];
                
                // Create each bag
                bagPositions.forEach((pos, index) => {
                    // Choose template based on type
                    const template = pos.type === 'bag1' ? this.bag1Template : this.bag2Template;
                    const bag = template.clone();
                    
                    // Position bag
                    bag.position.set(pos.x, 0, pos.z);
                    bag.rotation.y = pos.rotation;
                    
                    // Set bag properties
                    bag.userData = {
                        isPickupable: true,
                        bagIndex: index,
                        weight: Math.random() * 0.3 + 0.7 // Random weight between 0.7 and 1.0
                    };
                    
                    // Add to scene
                    this.scene.add(bag);
                    
                    // Add to available bags
                    this.availableBags.push(bag);
                });
            }
            
            updateLoadingProgress() {
                // Increment assets loaded
                this.state.assetsLoaded++;
                
                // Calculate progress
                const progress = this.state.assetsLoaded / this.state.totalAssets;
                
                // Update loading bar
                document.getElementById('loading-progress').style.width = `${progress * 100}%`;
                
                // Check if all assets are loaded
                if (this.state.assetsLoaded >= this.state.totalAssets) {
                    this.onAssetsLoaded();
                }
            }
            
            onAssetsLoaded() {
                // All assets loaded, start game
                setTimeout(() => {
                    // Hide loading screen
                    document.getElementById('loading-screen').style.display = 'none';
                    
                    // Show game UI
                    document.getElementById('balance-meter').style.display = 'block';
                    document.getElementById('item-counter').style.display = 'block';
                    
                    // Set game state to playing
                    this.state.isLoading = false;
                    this.state.isPlaying = true;
                    
                    console.log('Game started!');
                }, 1000);
            }
            
            handleInput(deltaTime) {
                // Movement keys
                const moveForward = this.keys['KeyW'] || false;
                const moveBackward = this.keys['KeyS'] || false;
                const moveLeft = this.keys['KeyA'] || false;
                const moveRight = this.keys['KeyD'] || false;
                
                // Action keys
                const isRunning = this.keys['ShiftLeft'] || false;
                const isPickingUp = this.keys['KeyE'] || false;
                
                // Skip if character isn't loaded
                if (!this.character) return;
                
                // Calculate movement direction
                let moveX = 0;
                let moveZ = 0;
                
                if (moveForward) moveZ -= 1;
                if (moveBackward) moveZ += 1;
                if (moveLeft) moveX -= 1;
                if (moveRight) moveX += 1;
                
                // Normalize for diagonal movement
                const length = Math.sqrt(moveX * moveX + moveZ * moveZ);
                if (length > 0) {
                    moveX /= length;
                    moveZ /= length;
                }
                
                // Calculate speed based on running and bag weight
                let baseSpeed = isRunning ? 5 : 3;
                
                // Reduce speed based on number of bags carried
                const bagWeight = this.state.bagsCarried * 0.15;
                const speedFactor = Math.max(0.3, 1 - bagWeight);
                const effectiveSpeed = baseSpeed * speedFactor;
                
                // Apply movement
                this.character.position.x += moveX * effectiveSpeed * deltaTime;
                this.character.position.z += moveZ * effectiveSpeed * deltaTime;
                
                // Rotate character to face movement direction
                if (length > 0) {
                    const targetRotation = Math.atan2(moveX, moveZ);
                    this.character.rotation.y = targetRotation;
                    
                    // Determine animation
                    if (this.state.bagsCarried > 0) {
                        // Carrying bags
                        const loadWeight = this.state.bagsCarried > 2 ? 'heavy' : 'medium';
                        const moveSpeed = isRunning ? 'run' : 'walk';
                        this.playAnimation(`carry_${moveSpeed}_${loadWeight}`);
                    } else {
                        // Not carrying anything
                        this.playAnimation(isRunning ? 'run' : 'walk');
                    }
                } else {
                    // Character is standing still
                    if (this.state.bagsCarried > 0) {
                        const loadWeight = this.state.bagsCarried > 2 ? 'heavy' : 'medium';
                        this.playAnimation(`carry_stand_${loadWeight}`);
                    } else {
                        this.playAnimation('tpose');
                    }
                }
                
                // Handle pickup
                if (isPickingUp && !this.state.gameOver) {
                    this.tryPickupBag();
                }
            }
            
            tryPickupBag() {
                // Skip if already carrying max bags or during animation
                if (this.state.bagsCarried >= this.state.maxBags || 
                    this.animations.current.includes('pickup')) return;
                
                // Find closest bag
                let closestBag = null;
                let closestDistance = 2; // Maximum pickup distance
                
                this.availableBags.forEach(bag => {
                    const distance = this.character.position.distanceTo(bag.position);
                    
                    if (distance < closestDistance) {
                        closestDistance = distance;
                        closestBag = bag;
                    }
                });
                
                if (closestBag) {
                    // Determine if bag is on car or ground
                    const pickupType = closestBag.userData.isOnCar ? 'pickup_high' : 'pickup_low';
                    
                    // Play pickup animation
                    this.playAnimation(pickupType, 0.3);
                    
                    // Set timeout to coincide with animation
                    setTimeout(() => {
                        // Remove from available bags
                        this.availableBags = this.availableBags.filter(bag => bag !== closestBag);
                        
                        // Hide the original bag
                        this.scene.remove(closestBag);
                        
                        // Increase carried bags counter
                        this.state.bagsCarried++;
                        
                        // Update UI
                        document.getElementById('item-counter').textContent = `Bags: ${this.state.bagsCarried}/${this.state.maxBags}`;
                        
                        // Create bag attached to character
                        this.attachBagToCharacter(closestBag.userData.type);
                        
                        // Transition to carry animation
                        const loadWeight = this.state.bagsCarried > 2 ? 'heavy' : 'medium';
                        this.playAnimation(`carry_stand_${loadWeight}`);
                    }, 1000); // Timing should match animation
                }
            }
            
            attachBagToCharacter(bagType) {
                if (!this.character) return;
                
                // Create attachment points if they don't exist
                if (this.attachPoints.length === 0) {
                    // Define attachment points based on number of bags
                    const points = [
                        { x: 0, y: 1.2, z: 0.2 },  // First bag - center
                        { x: 0.2, y: 1.2, z: 0.2 }, // Second bag - right side
                        { x: -0.2, y: 1.2, z: 0.2 }, // Third bag - left side
                        { x: 0, y: 1.4, z: 0.2 },  // Fourth bag - top center
                        { x: 0.1, y: 1.4, z: 0.3 }  // Fifth bag - top right
                    ];
                    
                    points.forEach((point, index) => {
                        const attachPoint = new THREE.Object3D();
                        attachPoint.position.set(point.x, point.y, point.z);
                        this.character.add(attachPoint);
                        this.attachPoints.push(attachPoint);
                    });
                }
                
                // Choose template based on type
                const template = bagType === 'bag1' ? this.bag1Template : this.bag2Template;
                
                // Create new bag instance
                const bag = template.clone();
                bag.scale.set(0.5, 0.5, 0.5);
                
                // Attach to appropriate point
                const attachIndex = this.state.bagsCarried - 1;
                if (this.attachPoints[attachIndex]) {
                    this.attachPoints[attachIndex].add(bag);
                }
                
                // Adjust balance difficulty based on bag position
                if (attachIndex > 1) {
                    // Bags beyond the first two make balance harder
                    this.state.balanceStability *= 0.8;
                }
            }
            
            dropAllBags() {
                // Drop all carried bags
                this.bags.forEach(bag => {
                    // Remove from character
                    this.character.remove(bag.mesh);
                    
                    // Reset world position
                    this.scene.add(bag.mesh);
                    
                    // Position on ground near character
                    const angle = Math.random() * Math.PI * 2;
                    const distance = Math.random() * 2 + 1;
                    
                    bag.mesh.position.set(
                        this.character.position.x + Math.cos(angle) * distance,
                        0,
                        this.character.position.z + Math.sin(angle) * distance
                    );
                    
                    bag.mesh.rotation.set(
                        Math.random() * 0.5,
                        Math.random() * Math.PI * 2,
                        Math.random() * 0.5
                    );
                    
                    // Reset attachment point
                    bag.attachPoint.bag = null;
                    
                    // Add back to available bags
                    this.availableBags.push(bag.mesh);
                });
                
                // Clear carried bags
                this.bags = [];
                this.state.bagsCarried = 0;
                
                // Update bag counter
                document.getElementById('bag-counter').textContent = `Bags: ${this.state.bagsCarried}/${this.state.maxBags}`;
                
                // Reset balance stability
                this.state.balanceStability = 1.0;
                
                // Play drop sound
                this.playSound('drop');
            }
            
            updateBalance(deltaTime) {
                // Skip if not carrying bags
                if (this.state.bagsCarried === 0) {
                    // Reset indicator position
                    document.getElementById('balance-indicator').style.left = '50%';
                    // Reset character rotation
                    if (this.character) this.character.rotation.z = 0;
                    return;
                }
                
                // Skip during pickup animation
                if (this.animations.current.includes('pickup')) return;
                
                // Calculate left vs right weight distribution
                let leftWeight = 0;
                let rightWeight = 0;
                
                this.attachPoints.forEach((point, index) => {
                    if (point.children.length > 0) {
                        const bagWeight = point.children[0].userData?.weight || 1;
                        
                        if (index === 0) { // center bag
                            leftWeight += bagWeight * 0.5;
                            rightWeight += bagWeight * 0.5;
                        } else if (index === 1) { // right side bag
                            rightWeight += bagWeight;
                        } else if (index === 2) { // left side bag
                            leftWeight += bagWeight;
                        } else if (index === 3) { // top center bag
                            leftWeight += bagWeight * 0.6; // Slightly destabilizing
                            rightWeight += bagWeight * 0.6;
                        } else if (index === 4) { // top right bag
                            rightWeight += bagWeight * 1.2; // Very destabilizing
                        }
                    }
                });
                
                // Calculate imbalance factor (-1 to 1, 0 is balanced)
                const totalWeight = leftWeight + rightWeight;
                const weightDifference = (rightWeight - leftWeight) / totalWeight;
                
                // Apply natural balance movement based on weight distribution
                const balanceShift = weightDifference * 0.01 * deltaTime * 5;
                
                // Balance difficulty scales with weight and stability
                const balanceDifficulty = totalWeight * 0.05 / this.state.balanceStability;
                
                // Random wobble based on difficulty
                const randomWobble = (Math.random() - 0.5) * balanceDifficulty;
                
                // Player input for balance
                const balanceLeft = this.keys['KeyQ'] || false;
                const balanceRight = this.keys['KeyE'] || false;
                
                let balanceInput = 0;
                if (balanceLeft) balanceInput -= 0.02;
                if (balanceRight) balanceInput += 0.02;
                
                // Update balance value - natural shift + player input + random wobble
                this.state.balance += balanceShift;
                this.state.balance += randomWobble * deltaTime * 2;
                this.state.balance += balanceInput;
                
                // Clamp balance between 0 and 1
                this.state.balance = Math.max(0, Math.min(1, this.state.balance));
                
                // Update UI
                const indicator = document.getElementById('balance-indicator');
                indicator.style.left = `${this.state.balance * 100}%`;
                
                // Visual feedback - color the balance meter based on stability
                const balanceMeter = document.getElementById('balance-meter');
                if (this.state.balance < 0.3 || this.state.balance > 0.7) {
                    balanceMeter.style.backgroundColor = 'rgba(255,0,0,0.5)';
                } else if (this.state.balance < 0.4 || this.state.balance > 0.6) {
                    balanceMeter.style.backgroundColor = 'rgba(255,165,0,0.5)';
                } else {
                    balanceMeter.style.backgroundColor = 'rgba(0,0,0,0.5)';
                }
                
                // Update character tilt
                if (this.character) {
                    // Tilt based on balance (convert 0-1 to -0.3 to 0.3 radians)
                    const tiltAmount = (this.state.balance - 0.5) * 0.6;
                    this.character.rotation.z = tiltAmount;
                    
                    // Handle stumbling animations
                    this.handleStumbleAnimations();
                }
            }
            
            handleStumbleAnimations() {
                if ((this.state.balance < 0.25 || this.state.balance > 0.75) && 
                    !this.state.isStumbling && !this.animations.current.includes('pickup') && 
                    !this.state.gameOver) {
                    
                    // Critical imbalance - heavy stumbling
                    const stumblingSound = new Audio('https://freesound.org/data/previews/448/448008_6142149-lq.mp3');
                    stumblingSound.volume = 0.3;
                    stumblingSound.play();
                    
                    // Show a warning message
                    this.showFloatingText("Whoa! I'm losing balance!", 1500);
                        
                    this.state.isStumbling = true;
                } 
                else if ((this.state.balance < 0.35 || this.state.balance > 0.65) && 
                         !this.state.isStumbling && !this.animations.current.includes('pickup') && 
                         !this.state.gameOver) {
                    
                    // Minor stumble
                    const minorStumbleSound = new Audio('https://freesound.org/data/previews/110/110011_1537422-lq.mp3');
                    minorStumbleSound.volume = 0.1;
                    minorStumbleSound.play();
                    
                    // Show a hint message
                    this.showFloatingText("Need to adjust!", 1000);
                        
                    this.state.isStumbling = true;
                } 
                else if (this.state.balance > 0.35 && this.state.balance < 0.65 && this.state.isStumbling) {
                    // Recover from stumble
                    this.state.isStumbling = false;
                }
                
                // Check if balance is completely lost
                if ((this.state.balance < 0.1 || this.state.balance > 0.9) && !this.state.gameOver) {
                    this.loseBalance();
                }
            }
            
            showFloatingText(message, duration = 2000) {
                // Create floating text element if it doesn't exist
                if (!document.getElementById('floating-text')) {
                    const floatingText = document.createElement('div');
                    floatingText.id = 'floating-text';
                    document.body.appendChild(floatingText);
                }
                
                // Get the element and update it
                const floatingText = document.getElementById('floating-text');
                floatingText.textContent = message;
                floatingText.style.opacity = '1';
                
                // Hide after duration
                setTimeout(() => {
                    floatingText.style.opacity = '0';
                }, duration);
            }
            
            loseBalance() {
                // Skip if already triggered
                if (this.state.gameOver) return;
                
                console.log("Lost balance!");
                
                // Play stumble animation
                this.playAnimation('stumble_fall', 0.3);
                
                // Drop all bags
                setTimeout(() => {
                    this.dropAllBags();
                }, 500);
                
                // Game over state
                this.state.gameOver = true;
                
                // Reset after delay
                setTimeout(() => {
                    this.state.gameOver = false;
                    this.state.balance = 0.5;
                    this.state.isStumbling = false;
                    
                    // Return to idle animation
                    this.playAnimation('tpose');
                    
                    console.log("Reset after fall");
                }, 3000);
            }
            
            updateCamera() {
                // Skip if character isn't loaded
                if (!this.character) return;
                
                // Set camera to follow behind character
                const targetPos = new THREE.Vector3();
                this.character.getWorldPosition(targetPos);
                
                // Get character's forward direction
                const forward = new THREE.Vector3(0, 0, -1);
                forward.applyQuaternion(this.character.quaternion);
                
                // Position camera behind character
                const cameraOffset = new THREE.Vector3()
                    .copy(forward)
                    .multiplyScalar(-5) // Distance behind
                    .add(new THREE.Vector3(0, 2, 0)); // Height offset
                
                const cameraTargetPos = new THREE.Vector3()
                    .copy(targetPos)
                    .add(cameraOffset);
                
                // Check if the calculated position is valid
                if (isNaN(cameraTargetPos.x) || isNaN(cameraTargetPos.y) || isNaN(cameraTargetPos.z)) {
                    console.error('Invalid camera position calculated');
                    return;
                }
                
                // Smoothly move camera
                this.camera.position.lerp(cameraTargetPos, 0.05);
                
                // Look at character
                this.controls.target.copy(targetPos);
                this.controls.update();
            }
            
            // Check if player reached house with all bags
            checkWinCondition() {
                // Win condition: carrying all bags and reaching the house
                if (this.state.bagsCarried >= this.state.maxBags) {
                    // Check if near house
                    const distanceToHouse = new THREE.Vector3()
                        .copy(this.character.position)
                        .distanceTo(this.house.position);
                    
                    if (distanceToHouse < 5) {
                        // Win!
                        this.state.gameOver = true;
                        
                        // Show win message
                        this.showFloatingText("Success! All groceries delivered in one trip!", 3000);
                        
                        // Advance to next level after delay
                        setTimeout(() => {
                            this.nextLevel();
                        }, 3000);
                    }
                }
            }
            
            showWinScreen() {
                if (this.winScreenShown) return;
                this.winScreenShown = true;
                
                console.log("Win condition met!");
                
                // Play win sound
                this.sounds.win.play();
                
                // Calculate score
                const timeBonus = Math.max(0, 30 - Math.floor((Date.now() - this.state.levelStartTime) / 1000));
                const balanceBonus = Math.floor(this.state.perfectBalanceTime);
                const bagBonus = this.state.bagsCarried * 50;
                const totalScore = timeBonus + balanceBonus + bagBonus;
                
                // Add to total score
                this.state.score += totalScore;
                
                // Create win screen
                const winScreen = document.createElement('div');
                winScreen.className = 'win-screen';
                
                // Check if this is the final level
                const isFinalLevel = this.state.currentLevel >= this.state.maxLevel;
                
                winScreen.innerHTML = `
                    <h1>Level ${this.state.currentLevel} Completed!</h1>
                    <p>You successfully carried all bags to the house.</p>
                    <div style="background: rgba(0,0,0,0.5); padding: 20px; margin: 20px; border-radius: 10px;">
                        <p>Time Bonus: ${timeBonus} points</p>
                        <p>Balance Bonus: ${balanceBonus} points</p>
                        <p>Bags Bonus: ${bagBonus} points</p>
                        <p style="font-size: 24px; margin-top: 10px;">Total Score: ${totalScore} points</p>
                    </div>
                    ${isFinalLevel ? 
                        `<p>Congratulations! You've completed all levels!</p>
                         <p>Final Score: ${this.state.score}</p>
                         <button id="restart-game-button">Play Again</button>` :
                        `<button id="next-level-button">Next Level</button>`
                    }
                `;
                
                // Add to document
                document.body.appendChild(winScreen);
                
                // Add button event
                setTimeout(() => {
                    if (isFinalLevel) {
                        document.getElementById('restart-game-button').addEventListener('click', () => {
                            document.body.removeChild(winScreen);
                            this.startLevel(1);
                        });
                    } else {
                        document.getElementById('next-level-button').addEventListener('click', () => {
                            document.body.removeChild(winScreen);
                            this.startLevel(this.state.currentLevel + 1);
                        });
                    }
                }, 100);
            }
            
            resetGame() {
                // Reset win flag
                this.winScreenShown = false;
                
                // Reset character position
                if (this.character) {
                    this.character.position.set(-10, 0, 0);
                }
                
                // Reset bags
                this.dropAllBags();
                
                // Recreate bags
                this.bags.forEach(bag => this.scene.remove(bag));
                this.bags = [];
                this.availableBags = [];
                this.createBagsOnCar();
                
                // Reset game state
                this.state.bagsCarried = 0;
                this.state.balance = 0.5;
                this.state.balanceStability = 1.0;
                this.state.gameOver = false;
                this.state.isStumbling = false;
                
                // Reset UI
                document.getElementById('item-counter').textContent = `Bags: ${this.state.bagsCarried}/${this.state.maxBags}`;
            }
            
            update(deltaTime) {
                // Skip if game isn't active
                if (!this.state.isPlaying) return;
                
                // Update animations
                if (this.animations.mixer) {
                    this.animations.mixer.update(deltaTime);
                }
                
                // Handle input (skip during game over)
                if (!this.state.gameOver) {
                    this.handleInput(deltaTime);
                }
                
                // Update balance
                this.updateBalance(deltaTime);
                
                // Track perfect balance time
                if (this.state.bagsCarried > 0 && 
                    this.state.balance > 0.4 && 
                    this.state.balance < 0.6) {
                    this.state.perfectBalanceTime += deltaTime;
                }
                
                // Update weather effects
                if (this.weather && this.weather.userData && this.weather.userData.update) {
                    this.weather.userData.update(deltaTime);
                }
                
                // Update obstacles
                if (this.obstacles) {
                    this.obstacles.forEach(obstacle => {
                        if (obstacle.userData && obstacle.userData.update) {
                            obstacle.userData.update(deltaTime);
                        }
                        
                        // Check for collision with character
                        if (this.character && obstacle.userData && obstacle.userData.effect) {
                            const distance = obstacle.position.distanceTo(this.character.position);
                            if (distance < 1.5) {
                                obstacle.userData.effect(this.character);
                            }
                        }
                    });
                }
                
                // Update camera
                this.updateCamera();
                
                // Check win condition
                this.checkWinCondition();
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                
                // Calculate delta time
                const deltaTime = this.clock.getDelta();
                
                // Update game
                this.update(deltaTime);
                
                // Render scene
                this.renderer.render(this.scene, this.camera);
            }
            
            addDebugConsole() {
                // Create debug console container
                const debugContainer = document.createElement('div');
                debugContainer.style.position = 'absolute';
                debugContainer.style.bottom = '10px';
                debugContainer.style.right = '10px';
                debugContainer.style.backgroundColor = 'rgba(0,0,0,0.7)';
                debugContainer.style.color = 'white';
                debugContainer.style.padding = '10px';
                debugContainer.style.borderRadius = '5px';
                debugContainer.style.maxHeight = '200px';
                debugContainer.style.overflow = 'auto';
                debugContainer.style.maxWidth = '300px';
                debugContainer.style.fontSize = '12px';
                debugContainer.id = 'debug-console';
                document.body.appendChild(debugContainer);
                
                // Override console.log and console.error
                const originalLog = console.log;
                const originalError = console.error;
                
                console.log = function() {
                    originalLog.apply(console, arguments);
                    const message = Array.from(arguments).join(' ');
                    debugContainer.innerHTML += `<div>${message}</div>`;
                    debugContainer.scrollTop = debugContainer.scrollHeight;
                };
                
                console.error = function() {
                    originalError.apply(console, arguments);
                    const message = Array.from(arguments).join(' ');
                    debugContainer.innerHTML += `<div style="color:red">${message}</div>`;
                    debugContainer.scrollTop = debugContainer.scrollHeight;
                };
            }
            
            handleMissingAssets() {
                // Create basic placeholder geometries for missing models
                if (!this.character) {
                    console.log("Creating placeholder for missing character model");
                    const geo = new THREE.CapsuleGeometry(0.5, 1, 4, 8);
                    const mat = new THREE.MeshStandardMaterial({color: 0x00ff00});
                    this.character = new THREE.Mesh(geo, mat);
                    this.character.position.set(-3, 1, 0);
                    this.scene.add(this.character);
                    
                    // Mock animation mixer to prevent errors
                    this.animations.mixer = new THREE.AnimationMixer(this.character);
                    this.animations.actions.tpose = {
                        fadeOut: () => {},
                        reset: () => {},
                        fadeIn: () => {},
                        play: () => {}
                    };
                    this.animations.current = 'tpose';
                }
                
                // Create simple car placeholder
                if (!this.car) {
                    console.log("Creating placeholder for missing car model");
                    const geo = new THREE.BoxGeometry(2, 1, 4);
                    const mat = new THREE.MeshStandardMaterial({color: 0x0000ff});
                    this.car = new THREE.Mesh(geo, mat);
                    this.car.position.set(-5, 0.5, 0);
                    this.scene.add(this.car);
                }
                
                // Create simple house placeholder
                if (!this.house) {
                    console.log("Creating placeholder for missing house model");
                    const geo = new THREE.BoxGeometry(4, 3, 4);
                    const mat = new THREE.MeshStandardMaterial({color: 0xff0000});
                    this.house = new THREE.Mesh(geo, mat);
                    this.house.position.set(5, 1.5, 0);
                    this.scene.add(this.house);
                }
                
                // Create placeholder bags if needed
                if (!this.bag1Template || !this.bag2Template || this.availableBags.length === 0) {
                    console.log("Creating placeholder bags");
                    
                    // Clear existing bags
                    this.availableBags = [];
                    
                    // Create bag templates if needed
                    if (!this.bag1Template) {
                        const bagGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
                        const bagMaterial = new THREE.MeshStandardMaterial({ color: 0x995522 });
                        this.bag1Template = new THREE.Mesh(bagGeometry, bagMaterial);
                    }
                    
                    if (!this.bag2Template) {
                        const bagGeometry = new THREE.BoxGeometry(0.6, 0.4, 0.4);
                        const bagMaterial = new THREE.MeshStandardMaterial({ color: 0x225599 });
                        this.bag2Template = new THREE.Mesh(bagGeometry, bagMaterial);
                    }
                    
                    // Create bags
                    this.createBags();
                }
                
                // Create placeholder trees if needed
                if (!this.treeTemplate) {
                    const treeGeometry = new THREE.ConeGeometry(1, 3, 8);
                    const treeMaterial = new THREE.MeshStandardMaterial({ color: 0x225522 });
                    this.treeTemplate = new THREE.Mesh(treeGeometry, treeMaterial);
                    
                    // Create trees
                    this.createTrees();
                }
                
                // Create placeholder rocks if needed
                if (!this.rocksTemplate) {
                    const rocksGroup = new THREE.Group();
                    
                    const rockGeometry = new THREE.DodecahedronGeometry(0.5, 0);
                    const rockMaterial = new THREE.MeshStandardMaterial({ color: 0x888888 });
                    
                    for (let i = 0; i < 3; i++) {
                        const rock = new THREE.Mesh(rockGeometry, rockMaterial);
                        rock.position.set(
                            (Math.random() - 0.5) * 1.5,
                            0.2,
                            (Math.random() - 0.5) * 1.5
                        );
                        rock.scale.set(
                            Math.random() * 0.5 + 0.5,
                            Math.random() * 0.5 + 0.5,
                            Math.random() * 0.5 + 0.5
                        );
                        rock.rotation.set(
                            Math.random() * Math.PI,
                            Math.random() * Math.PI,
                            Math.random() * Math.PI
                        );
                        rocksGroup.add(rock);
                    }
                    
                    this.rocksTemplate = rocksGroup;
                    
                    // Create rocks
                    this.createRocks();
                }
                
                // Create placeholder leaf piles if needed
                if (!this.leavesTemplate) {
                    const leavesGroup = new THREE.Group();
                    
                    const leavesGeometry = new THREE.CircleGeometry(1, 8);
                    const leavesMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0xDD8833, 
                        side: THREE.DoubleSide 
                    });
                    
                    const leafPile = new THREE.Mesh(leavesGeometry, leavesMaterial);
                    leafPile.rotation.x = -Math.PI / 2;
                    leafPile.position.y = 0.05; // Slightly above ground
                    leavesGroup.add(leafPile);
                    
                    this.leavesTemplate = leavesGroup;
                    
                    // Create leaf piles
                    this.createLeafPiles();
                }
                
                // Create procedural textures if needed
                if (!this.grassTexture) {
                    // Create a procedural grass texture
                    const canvas = document.createElement('canvas');
                    canvas.width = 512;
                    canvas.height = 512;
                    const ctx = canvas.getContext('2d');
                    
                    // Fill with green
                    ctx.fillStyle = '#7CFC00';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Add some variation
                    for (let i = 0; i < 5000; i++) {
                        const x = Math.random() * canvas.width;
                        const y = Math.random() * canvas.height;
                        const size = Math.random() * 3 + 1;
                        ctx.fillStyle = Math.random() > 0.5 ? '#86C300' : '#6CB800';
                        ctx.fillRect(x, y, size, size);
                    }
                    
                    this.grassTexture = new THREE.CanvasTexture(canvas);
                    this.grassTexture.wrapS = THREE.RepeatWrapping;
                    this.grassTexture.wrapT = THREE.RepeatWrapping;
                    this.grassTexture.repeat.set(20, 20);
                    
                    // Update ground texture
                    this.updateGroundTexture();
                }
                
                // Update loading progress to complete
                this.state.assetsLoaded = this.state.totalAssets;
                this.updateLoadingProgress();
            }
            
            updateLoadingProgress() {
                this.state.assetsLoaded++;
                const progress = Math.min(this.state.assetsLoaded / this.state.totalAssets, 1);
                
                // Update loading bar
                document.getElementById('loading-progress').style.width = `${progress * 100}%`;
                document.getElementById('loading-text').textContent = 
                    `Loading assets... ${Math.round(progress * 100)}%`;
                
                // Check if all assets are loaded
                if (progress >= 1) {
                    this.finishLoading();
                }
            }
            
            // Add a points system based on speed and balance maintenance
            calculateScore() {
                const timeBonus = Math.max(0, 100 - this.gameTimer);
                const balanceBonus = Math.floor(this.perfectBalanceTime * 10);
                const bagBonus = this.state.bagsCarried * 20;
                
                return timeBonus + balanceBonus + bagBonus;
            }
            
            // Unlockable items like better shoes for better balance,
            // stronger arms to carry more bags, etc.
            unlockUpgrade(type) {
                switch(type) {
                    case 'shoes':
                        this.playerUpgrades.balanceStability += 0.1;
                        break;
                    case 'arms':
                        this.state.maxBags += 1;
                        break;
                    case 'cart':
                        // Special item that lets player carry many bags but moves slower
                        this.playerUpgrades.hasCart = true;
                        this.state.maxBags = 10;
                        this.playerSpeed *= 0.7;
                        break;
                }
            }
            
            // Add this method to check if URLs are accessible
            checkAssetUrls() {
                const urls = Object.values(this.assets);
                let checkedCount = 0;
                
                // Try original paths first
                urls.forEach(url => {
                    fetch(url, { method: 'HEAD' })
                        .then(response => {
                            if (response.ok) {
                                console.log(`✅ Asset URL valid: ${url}`);
                            } else {
                                console.error(`❌ Asset URL returns ${response.status}: ${url}`);
                                
                                // Try with raw GitHub URLs
                                this.tryRawGitHubUrls();
                            }
                        })
                        .catch(error => {
                            console.error(`❌ Asset URL check failed: ${url}`);
                            // Try with raw GitHub URLs
                            this.tryRawGitHubUrls();
                        })
                        .finally(() => {
                            checkedCount++;
                            if (checkedCount === urls.length) {
                                console.log('URL check complete');
                            }
                        });
                });
            }
            
            tryRawGitHubUrls() {
                // Only do this once
                if (this.triedRawUrls) return;
                this.triedRawUrls = true;
                
                console.log("Trying raw GitHub URLs...");
                
                // Use raw GitHub URLs as fallback
                this.assets = {
                    character: 'https://raw.githubusercontent.com/anythingshop/OneTrip/main/onetrip_maincharacter.glb',
                    bag1: 'https://raw.githubusercontent.com/anythingshop/OneTrip/main/newbag.glb',
                    bag2: 'https://raw.githubusercontent.com/anythingshop/OneTrip/main/bag2.glb',
                    car: 'https://raw.githubusercontent.com/anythingshop/OneTrip/main/car.glb',
                    house: 'https://raw.githubusercontent.com/anythingshop/OneTrip/main/house.glb'
                };
                
                // Restart asset loading
                this.loadAssets();
            }

            // Add environmental hazards and obstacles
            setupLevel(levelNumber = 1) {
                // Clear any existing obstacles
                if (this.obstacles) {
                    this.obstacles.forEach(obstacle => this.scene.remove(obstacle));
                }
                this.obstacles = [];
                
                // Level configurations
                const levels = [
                    { // Level 1 - Basic path
                        weather: 'clear',
                        obstacles: []
                    },
                    { // Level 2 - Puddles
                        weather: 'light_rain',
                        obstacles: [
                            { type: 'puddle', x: -5, z: 0, size: 2 },
                            { type: 'puddle', x: 0, z: 2, size: 1.5 }
                        ]
                    },
                    { // Level 3 - Neighbors and more
                        weather: 'rainy',
                        obstacles: [
                            { type: 'puddle', x: -8, z: 0, size: 2 },
                            { type: 'puddle', x: -3, z: 0, size: 1.5 },
                            { type: 'neighbor', x: 0, z: 0, patrolRadius: 3, speed: 1 }
                        ]
                    }
                ];
                
                // Get level data (default to level 1 if not found)
                const level = levels[levelNumber - 1] || levels[0];
                
                // Set up weather
                this.setupWeather(level.weather);
                
                // Create obstacles
                level.obstacles.forEach(obstacle => {
                    this.createObstacle(obstacle.type, obstacle);
                });
                
                // Update UI with level info
                this.showFloatingText(`Level ${levelNumber}`, 3000);
                
                return level;
            }

            createObstacle(type, options) {
                let obstacle;
                
                switch(type) {
                    case 'puddle':
                        obstacle = this.createPuddle(options);
                        break;
                    case 'neighbor':
                        obstacle = this.createNeighbor(options);
                        break;
                    case 'ice':
                        obstacle = this.createIce(options);
                        break;
                }
                
                if (obstacle) {
                    this.obstacles.push(obstacle);
                    this.scene.add(obstacle);
                }
                
                return obstacle;
            }

            createPuddle(options) {
                const size = options.size || 2;
                const puddle = new THREE.Group();
                puddle.position.set(options.x, 0.01, options.z);
                
                // Create puddle mesh
                const puddleGeo = new THREE.CircleGeometry(size, 32);
                const puddleMat = new THREE.MeshStandardMaterial({
                    color: 0x2196F3,
                    transparent: true,
                    opacity: 0.7,
                    metalness: 0.9,
                    roughness: 0.1
                });
                
                const puddleMesh = new THREE.Mesh(puddleGeo, puddleMat);
                puddleMesh.rotation.x = -Math.PI / 2; // Flat on ground
                puddle.add(puddleMesh);
                
                // Add ripple animation
                const rippleGeo = new THREE.CircleGeometry(size * 0.8, 32);
                const rippleMat = new THREE.MeshBasicMaterial({
                    color: 0xFFFFFF,
                    transparent: true,
                    opacity: 0.2
                });
                
                const rippleMesh = new THREE.Mesh(rippleGeo, rippleMat);
                rippleMesh.rotation.x = -Math.PI / 2;
                rippleMesh.position.y = 0.02;
                puddle.add(rippleMesh);
                
                // Replace GSAP animation code with plain JS
                animateRipple = () => {
                    rippleMesh.scale.set(1, 1, 1);
                    rippleMesh.material.opacity = 0.3;
                    
                    // Use simple animation with requestAnimationFrame instead of GSAP
                    let startTime = performance.now();
                    const duration = 2000; // 2 seconds
                    
                    const animate = (currentTime) => {
                        const elapsed = currentTime - startTime;
                        const progress = Math.min(elapsed / duration, 1);
                        
                        // Scale up
                        const scale = 1 + (0.5 * progress);
                        rippleMesh.scale.set(scale, scale, scale);
                        
                        // Fade out
                        rippleMesh.material.opacity = 0.3 * (1 - progress);
                        
                        if (progress < 1) {
                            requestAnimationFrame(animate);
                        } else {
                            // Reset and schedule next ripple
                            setTimeout(animateRipple, Math.random() * 3000);
                        }
                    };
                    
                    requestAnimationFrame(animate);
                };
                
                setTimeout(animateRipple, Math.random() * 3000);
                
                // Add obstacle data and collision effect
                puddle.userData = {
                    type: 'puddle',
                    size: size,
                    effect: (character) => {
                        // Slow down player and make balance harder when walking through
                        this.state.balanceStability *= 0.7;
                        
                        // Play splash sound
                        const splashSound = new Audio('https://freesound.org/data/previews/60/60779_71257-lq.mp3');
                        splashSound.volume = 0.2;
                        splashSound.play();
                        
                        // Show splash effect
                        this.createSplashEffect(puddle.position.x, puddle.position.z);
                        
                        // Show message
                        this.showFloatingText("Splish splash!", 1000);
                        
                        // Reset stability after a delay
                        setTimeout(() => {
                            this.state.balanceStability /= 0.7;
                        }, 2000);
                    }
                };
                
                return puddle;
            }

            createNeighbor(options) {
                const neighbor = new THREE.Group();
                neighbor.position.set(options.x, 0, options.z);
                
                // Create character
                const bodyGeo = new THREE.CapsuleGeometry(0.5, 1, 8, 8);
                const headGeo = new THREE.SphereGeometry(0.3, 16, 16);
                const bodyMat = new THREE.MeshStandardMaterial({ color: 0xFF5722 });
                const headMat = new THREE.MeshStandardMaterial({ color: 0xE0A080 });
                
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                body.position.y = 0.75;
                neighbor.add(body);
                
                const head = new THREE.Mesh(headGeo, headMat);
                head.position.y = 1.8;
                neighbor.add(head);
                
                // Add speech bubble
                const speech = document.createElement('div');
                speech.style.position = 'absolute';
                speech.style.padding = '10px';
                speech.style.backgroundColor = 'white';
                speech.style.borderRadius = '5px';
                speech.style.display = 'none';
                speech.style.width = '150px';
                speech.style.textAlign = 'center';
                speech.style.zIndex = '10';
                speech.innerHTML = "Hey neighbor! Need a hand?";
                document.body.appendChild(speech);
                
                // Set up patrol behavior
                neighbor.userData = {
                    type: 'neighbor',
                    speech: speech,
                    patrolRadius: options.patrolRadius || 3,
                    patrolAngle: Math.random() * Math.PI * 2,
                    patrolSpeed: options.speed || 1,
                    originalX: options.x,
                    originalZ: options.z,
                    speechTimer: 0,
                    update: (deltaTime) => {
                        // Move in a circular patrol
                        neighbor.userData.patrolAngle += neighbor.userData.patrolSpeed * deltaTime * 0.5;
                        const x = neighbor.userData.originalX + Math.cos(neighbor.userData.patrolAngle) * neighbor.userData.patrolRadius;
                        const z = neighbor.userData.originalZ + Math.sin(neighbor.userData.patrolAngle) * neighbor.userData.patrolRadius;
                        
                        // Look in movement direction
                        const angle = Math.atan2(
                            z - neighbor.position.z,
                            x - neighbor.position.x
                        );
                        neighbor.rotation.y = angle;
                        
                        // Smooth movement
                        neighbor.position.x = THREE.MathUtils.lerp(neighbor.position.x, x, 0.1);
                        neighbor.position.z = THREE.MathUtils.lerp(neighbor.position.z, z, 0.1);
                        
                        // Update speech bubble position
                        if (this.camera && neighbor.userData.speech) {
                            const vector = new THREE.Vector3();
                            vector.setFromMatrixPosition(head.matrixWorld);
                            vector.project(this.camera);
                            
                            const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
                            const y = -(vector.y * 0.5 - 0.5) * window.innerHeight;
                            
                            neighbor.userData.speech.style.left = x - 75 + 'px';
                            neighbor.userData.speech.style.top = y - 70 + 'px';
                        }
                        
                        // Check distance to player
                        if (this.character) {
                            const distToPlayer = neighbor.position.distanceTo(this.character.position);
                            if (distToPlayer < 3) {
                                // Show speech bubble when player is close
                                neighbor.userData.speech.style.display = 'block';
                                
                                // Randomly say something new
                                neighbor.userData.speechTimer += deltaTime;
                                if (neighbor.userData.speechTimer > 5) {
                                    neighbor.userData.speechTimer = 0;
                                    
                                    const phrases = [
                                        "Hey neighbor! Need a hand?",
                                        "That's a lot of bags you got there!",
                                        "Going for the one-trip challenge?",
                                        "You're gonna drop those...",
                                        "Impressive balancing skills!",
                                        "My record is 7 bags in one trip!"
                                    ];
                                    
                                    neighbor.userData.speech.innerHTML = phrases[Math.floor(Math.random() * phrases.length)];
                                }
                                
                                // Cause distraction (make balance harder)
                                if (this.state.bagsCarried > 0) {
                                    this.state.balanceStability *= 0.99;
                                }
                            } else {
                                neighbor.userData.speech.style.display = 'none';
                                neighbor.userData.speechTimer = 0;
                            }
                        }
                    },
                    effect: (character) => {
                        // Bumping into neighbor
                        this.state.balance += (Math.random() > 0.5 ? 0.1 : -0.1);
                        
                        // Say something when bumped
                        neighbor.userData.speech.style.display = 'block';
                        neighbor.userData.speech.innerHTML = "Hey! Watch where you're going!";
                        
                        // Play bumping sound
                        const bumpSound = new Audio('https://freesound.org/data/previews/331/331912_3248244-lq.mp3');
                        bumpSound.volume = 0.3;
                        bumpSound.play();
                    }
                };
                
                return neighbor;
            }

            setupWeather(type) {
                // Clear any existing weather
                if (this.weather) {
                    this.scene.remove(this.weather);
                    this.weather = null;
                }
                
                switch(type) {
                    case 'light_rain':
                        this.createRain(5000, 0.2);
                        // Slightly darken sky
                        this.scene.background = new THREE.Color(0x6b9dc9);
                        // Make ground slightly darker
                        this.ground.material.color.set(0x6dba00);
                        break;
                        
                    case 'rainy':
                        this.createRain(15000, 0.5);
                        // Darken sky more
                        this.scene.background = new THREE.Color(0x4a6d8e);
                        // Make ground dark and wet
                        this.ground.material.color.set(0x5d9900);
                        this.ground.material.roughness = 0.3;
                        break;
                        
                    case 'clear':
                    default:
                        // Reset to default
                        this.scene.background = new THREE.Color(0x87CEEB);
                        this.ground.material.color.set(0x7CFC00);
                        this.ground.material.roughness = 0.8;
                        break;
                }
            }

            createRain(count, intensity) {
                const rainGeometry = new THREE.BufferGeometry();
                const rainVertices = [];
                
                // Generate rain drops in a large area
                for (let i = 0; i < count; i++) {
                    const x = (Math.random() - 0.5) * 100;
                    const y = Math.random() * 50;
                    const z = (Math.random() - 0.5) * 100;
                    
                    rainVertices.push(x, y, z);
                }
                
                rainGeometry.setAttribute('position', new THREE.Float32BufferAttribute(rainVertices, 3));
                
                // Create material for raindrops
                const rainMaterial = new THREE.PointsMaterial({
                    color: 0xaaaaaa,
                    size: 0.1,
                    transparent: true,
                    opacity: 0.6
                });
                
                // Create the rain particle system
                this.weather = new THREE.Points(rainGeometry, rainMaterial);
                this.scene.add(this.weather);
                
                // Rain properties for animation
                this.weather.userData = {
                    type: 'rain',
                    intensity: intensity,
                    update: (deltaTime) => {
                        // Move rain down
                        const positions = this.weather.geometry.attributes.position.array;
                        
                        for (let i = 0; i < positions.length; i += 3) {
                            // Move each drop down
                            positions[i + 1] -= 10 * intensity * deltaTime;
                            
                            // Reset drops that go below the ground
                            if (positions[i + 1] < 0) {
                                positions[i + 1] = 50; // Move to top
                                positions[i] = (Math.random() - 0.5) * 100; // Random x
                                positions[i + 2] = (Math.random() - 0.5) * 100; // Random z
                            }
                        }
                        
                        this.weather.geometry.attributes.position.needsUpdate = true;
                        
                        // Make game slightly more difficult in rain
                        if (this.state.bagsCarried > 0) {
                            this.state.balanceStability = THREE.MathUtils.lerp(
                                this.state.balanceStability,
                                1.0 - (intensity * 0.3),
                                0.01
                            );
                        }
                    }
                };
            }

            startLevel(levelNumber) {
                // Reset game state
                this.resetGame();
                
                // Set level
                this.state.currentLevel = levelNumber;
                
                // Configure level elements
                const level = this.setupLevel(levelNumber);
                
                // Start level timer
                this.state.levelStartTime = Date.now();
                this.state.perfectBalanceTime = 0;
                
                // Show level intro
                this.showLevelIntro(levelNumber);
            }

            showLevelIntro(levelNumber) {
                // Create level intro screen
                const introScreen = document.createElement('div');
                introScreen.className = 'win-screen';
                
                const levelNames = [
                    "The Driveway",
                    "Rainy Day",
                    "The Nosy Neighbor"
                ];
                
                const levelObjectives = [
                    "Carry all 5 bags from your car to your house in one trip!",
                    "Watch out for puddles that can affect your balance!",
                    "Don't get distracted by your chatty neighbor!"
                ];
                
                introScreen.innerHTML = `
                    <h1>Level ${levelNumber}: ${levelNames[levelNumber-1] || 'Challenge'}</h1>
                    <p>${levelObjectives[levelNumber-1] || 'Get all bags home in one trip!'}</p>
                    <p>Balance carefully and distribute weight evenly</p>
                    <button id="start-level-button">Start Level</button>
                `;
                
                // Add to document
                document.body.appendChild(introScreen);
                
                // Add start button event
                setTimeout(() => {
                    document.getElementById('start-level-button').addEventListener('click', () => {
                        document.body.removeChild(introScreen);
                        // Game already set up, just start playing
                        this.state.isPlaying = true;
                    });
                }, 100);
            }

            // Add this helper function to create the splash effect
            createSplashEffect(x, z) {
                // Create particle system for splash
                const particleCount = 20;
                const particles = new THREE.Group();
                particles.position.set(x, 0.1, z);
                
                for (let i = 0; i < particleCount; i++) {
                    const particle = new THREE.Mesh(
                        new THREE.SphereGeometry(0.05, 4, 4),
                        new THREE.MeshBasicMaterial({ color: 0x2196F3 })
                    );
                    
                    // Random position around center
                    const angle = Math.random() * Math.PI * 2;
                    const radius = Math.random() * 0.5;
                    particle.position.x = Math.cos(angle) * radius;
                    particle.position.z = Math.sin(angle) * radius;
                    
                    // Initial y velocity
                    particle.userData = {
                        velocity: 0.05 + Math.random() * 0.1,
                        gravity: -0.005
                    };
                    
                    particles.add(particle);
                }
                
                this.scene.add(particles);
                
                // Add to update loop
                const splashUpdate = (deltaTime) => {
                    let allFallen = true;
                    
                    particles.children.forEach(particle => {
                        // Apply gravity
                        particle.userData.velocity += particle.userData.gravity;
                        
                        // Update position
                        particle.position.y += particle.userData.velocity;
                        
                        // Check if still above ground
                        if (particle.position.y > 0) {
                            allFallen = false;
                        }
                    });
                    
                    // Remove when all particles have fallen
                    if (allFallen) {
                        this.scene.remove(particles);
                        return false; // Remove from update loop
                    }
                    
                    return true; // Continue updating
                };
                
                // Add to a list of effects to update
                if (!this.effects) this.effects = [];
                this.effects.push(splashUpdate);
            }
            
            setupSounds() {
                // Use verified, working sound URLs from Freesound
                this.sounds = {
                    footstep: new Audio('https://freesound.org/data/previews/156/156031_2703297-lq.mp3'),
                    leaves: new Audio('https://freesound.org/data/previews/362/362205_5399929-lq.mp3'),
                    pickup: new Audio('https://freesound.org/data/previews/572/572882_12558596-lq.mp3'),
                    drop: new Audio('https://freesound.org/data/previews/432/432587_8157919-lq.mp3'),
                    balance: new Audio('https://freesound.org/data/previews/110/110011_1537422-lq.mp3'),
                    fall: new Audio('https://freesound.org/data/previews/160/160708_2703896-lq.mp3')
                };
                
                // Set volume for all sounds
                Object.values(this.sounds).forEach(sound => {
                    sound.volume = 0.2;
                });
            }
            
            playSound(name) {
                if (this.sounds[name]) {
                    // Clone the sound to allow overlapping playback
                    const sound = this.sounds[name].cloneNode();
                    sound.volume = this.sounds[name].volume;
                    sound.play().catch(e => console.log("Sound play prevented:", e));
                }
            }

            setupMobileControls() {
                // Get UI elements
                const joystick = document.getElementById('joystick');
                const joystickKnob = document.getElementById('joystick-knob');
                const pickupButton = document.getElementById('pickup-button');
                const balanceLeftButton = document.getElementById('balance-left-button');
                const balanceRightButton = document.getElementById('balance-right-button');
                
                // Show mobile controls
                joystick.style.display = 'block';
                document.getElementById('action-buttons').style.display = 'flex';
                
                // Joystick variables
                let joystickActive = false;
                let joystickOrigin = { x: 0, y: 0 };
                
                // Joystick touch start
                joystick.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    const rect = joystick.getBoundingClientRect();
                    joystickOrigin.x = touch.clientX - rect.left;
                    joystickOrigin.y = touch.clientY - rect.top;
                    joystickActive = true;
                });
                
                // Joystick touch move
                joystick.addEventListener('touchmove', (e) => {
                    if (!joystickActive) return;
                    e.preventDefault();
                    
                    const touch = e.touches[0];
                    const rect = joystick.getBoundingClientRect();
                    const x = touch.clientX - rect.left;
                    const y = touch.clientY - rect.top;
                    
                    // Calculate distance from origin
                    const dx = x - rect.width/2;
                    const dy = y - rect.height/2;
                    
                    // Normalize to -1 to 1
                    this.input.moveX = Math.min(1, Math.max(-1, dx / 35));
                    this.input.moveZ = Math.min(1, Math.max(-1, dy / 35));
                    
                    // Move knob (clamped to circle)
                    const angle = Math.atan2(dy, dx);
                    const distance = Math.min(35, Math.sqrt(dx*dx + dy*dy));
                    joystickKnob.style.left = `${rect.width/2 + Math.cos(angle) * distance}px`;
                    joystickKnob.style.top = `${rect.height/2 + Math.sin(angle) * distance}px`;
                    
                    // Set running state based on joystick distance
                    this.input.isRunning = distance > 25;
                });
                
                // Joystick touch end
                joystick.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    joystickActive = false;
                    joystickKnob.style.left = '50%';
                    joystickKnob.style.top = '50%';
                    
                    // Reset movement
                    this.input.moveX = 0;
                    this.input.moveZ = 0;
                    this.input.isRunning = false;
                });
            }
            
            setupUI() {
                // Level screen event handler
                document.getElementById('start-level-button').addEventListener('click', () => {
                    document.getElementById('level-screen').style.opacity = '0';
                    document.getElementById('level-screen').style.pointerEvents = 'none';
                    
                    // Start gameplay
                    this.state.isPlaying = true;
                });
            }
            
            createTrees() {
                if (!this.treeTemplate) return;
                
                // Tree placement positions
                const treePositions = [
                    { x: -20, z: -15, scale: 1.0 },
                    { x: -18, z: 10, scale: 0.8 },
                    { x: 20, z: -8, scale: 1.2 },
                    { x: 25, z: 12, scale: 0.9 },
                    { x: -10, z: -20, scale: 1.1 },
                    { x: 5, z: 18, scale: 0.7 },
                    { x: 15, z: -15, scale: 1.0 }
                ];
                
                // Create each tree
                treePositions.forEach(pos => {
                    const tree = this.treeTemplate.clone();
                    tree.position.set(pos.x, 0, pos.z);
                    tree.scale.set(pos.scale, pos.scale, pos.scale);
                    
                    // Add random rotation for variety
                    tree.rotation.y = Math.random() * Math.PI * 2;
                    
                    // Enable shadows
                    tree.traverse(node => {
                        if (node.isMesh) {
                            node.castShadow = true;
                            node.receiveShadow = true;
                        }
                    });
                    
                    this.scene.add(tree);
                });
            }
            
            createRocks() {
                if (!this.rocksTemplate) return;
                
                // Rock placement positions
                const rockPositions = [
                    { x: -8, z: -10, scale: 0.7 },
                    { x: 12, z: 8, scale: 0.5 },
                    { x: -15, z: 5, scale: 0.6 },
                    { x: 7, z: -12, scale: 0.4 }
                ];
                
                // Create each rock formation
                rockPositions.forEach(pos => {
                    const rocks = this.rocksTemplate.clone();
                    rocks.position.set(pos.x, 0, pos.z);
                    rocks.scale.set(pos.scale, pos.scale, pos.scale);
                    
                    // Add random rotation for variety
                    rocks.rotation.y = Math.random() * Math.PI * 2;
                    
                    // Enable shadows
                    rocks.traverse(node => {
                        if (node.isMesh) {
                            node.castShadow = true;
                            node.receiveShadow = true;
                        }
                    });
                    
                    this.scene.add(rocks);
                });
            }
            
            createLeafPiles() {
                if (!this.leavesTemplate) return;
                
                // Leaf pile placement positions - some along the path!
                const leafPositions = [
                    { x: -5, z: 0, scale: 0.8 },  // On the path to create an obstacle
                    { x: 5, z: 0, scale: 0.7 },   // Another one on the path
                    { x: -10, z: -4, scale: 0.6 },
                    { x: 8, z: 3, scale: 0.9 }
                ];
                
                // Create each leaf pile
                leafPositions.forEach(pos => {
                    const leaves = this.leavesTemplate.clone();
                    leaves.position.set(pos.x, 0, pos.z);
                    leaves.scale.set(pos.scale, pos.scale, pos.scale);
                    
                    // Add random rotation for variety
                    leaves.rotation.y = Math.random() * Math.PI * 2;
                    
                    // Enable shadows
                    leaves.traverse(node => {
                        if (node.isMesh) {
                            node.castShadow = true;
                            node.receiveShadow = true;
                        }
                    });
                    
                    // Add special properties for gameplay
                    leaves.userData = {
                        isObstacle: true,
                        type: 'leaves',
                        effect: () => this.onLeafPileContact()
                    };
                    
                    this.scene.add(leaves);
                    
                    // Add to obstacles list if it doesn't exist
                    if (!this.obstacles) this.obstacles = [];
                    this.obstacles.push(leaves);
                });
            }
            
            onLeafPileContact() {
                // Don't trigger too often
                if (this.leafPileCooldown) return;
                this.leafPileCooldown = true;
                
                // Play rustling sound
                this.playSound('leaves');
                
                // Make balance harder for a moment
                const originalStability = this.state.balanceStability;
                this.state.balanceStability *= 0.6;
                
                // Show feedback
                this.showFloatingText("Careful in the leaves!", 1000);
                
                // Reset stability after a delay
                setTimeout(() => {
                    this.state.balanceStability = originalStability;
                    this.leafPileCooldown = false;
                }, 2000);
            }
            
            createAttachmentPoints() {
                if (!this.character) return;
                
                // Define attachment points relative to character
                const attachmentDefinitions = [
                    { hand: 'left', offsetX: -0.5, offsetY: 1.2, offsetZ: 0.2 },
                    { hand: 'right', offsetX: 0.5, offsetY: 1.2, offsetZ: 0.2 },
                    { hand: 'left', offsetX: -0.8, offsetY: 0.9, offsetZ: 0.4 },
                    { hand: 'right', offsetX: 0.8, offsetY: 0.9, offsetZ: 0.4 },
                    { hand: 'top', offsetX: 0, offsetY: 1.5, offsetZ: 0.3 }
                ];
                
                // Create attachment points
                attachmentDefinitions.forEach((def) => {
                    const point = new THREE.Object3D();
                    point.position.set(def.offsetX, def.offsetY, def.offsetZ);
                    this.character.add(point);
                    
                    this.attachPoints.push({
                        point: point,
                        hand: def.hand,
                        bag: null
                    });
                });
            }
            
            createPlaceholders() {
                // Create placeholder character if needed
                if (!this.character) {
                    console.log("Creating placeholder character");
                    
                    // Create simple character
                    const characterGeometry = new THREE.CapsuleGeometry(0.5, 1, 4, 8);
                    const characterMaterial = new THREE.MeshStandardMaterial({ color: 0x3366ff });
                    this.character = new THREE.Mesh(characterGeometry, characterMaterial);
                    this.character.position.set(-10, 1, 0);
                    this.character.castShadow = true;
                    this.scene.add(this.character);
                    
                    // Create simple attachment points
                    this.createAttachmentPoints();
                }
                
                // Create placeholder car if needed
                if (!this.car) {
                    console.log("Creating placeholder car");
                    
                    // Create simple car body
                    const carGeometry = new THREE.BoxGeometry(4, 1.5, 2);
                    const carMaterial = new THREE.MeshStandardMaterial({ color: 0xcc0000 });
                    this.car = new THREE.Mesh(carGeometry, carMaterial);
                    this.car.position.set(-15, 0.75, 0);
                    this.car.castShadow = true;
                    this.scene.add(this.car);
                }
                
                // Create placeholder house if needed
                if (!this.house) {
                    console.log("Creating placeholder house");
                    
                    // Create simple house
                    const houseGroup = new THREE.Group();
                    
                    // House body
                    const houseGeometry = new THREE.BoxGeometry(5, 3, 4);
                    const houseMaterial = new THREE.MeshStandardMaterial({ color: 0xdddddd });
                    const houseBody = new THREE.Mesh(houseGeometry, houseMaterial);
                    houseBody.position.y = 1.5;
                    houseBody.castShadow = true;
                    houseGroup.add(houseBody);
                    
                    // House roof
                    const roofGeometry = new THREE.ConeGeometry(3.5, 2, 4);
                    const roofMaterial = new THREE.MeshStandardMaterial({ color: 0x995555 });
                    const roof = new THREE.Mesh(roofGeometry, roofMaterial);
                    roof.position.y = 4;
                    roof.rotation.y = Math.PI / 4;
                    roof.castShadow = true;
                    houseGroup.add(roof);
                    
                    houseGroup.position.set(15, 0, 0);
                    this.house = houseGroup;
                    this.scene.add(this.house);
                }
            }
            
            finishLoading() {
                setTimeout(() => {
                    // Hide loading screen
                    document.getElementById('loading-screen').style.opacity = '0';
                    setTimeout(() => {
                        document.getElementById('loading-screen').style.display = 'none';
                    }, 500);
                    
                    // Show game UI
                    document.getElementById('balance-meter').style.opacity = '1';
                    document.getElementById('bag-counter').style.opacity = '1';
                    
                    // Show level screen
                    document.getElementById('level-screen').style.opacity = '1';
                    document.getElementById('level-screen').style.pointerEvents = 'auto';
                    
                    // Mark loading as complete
                    this.state.isLoading = false;
                }, 1000);
            }

            processInput() {
                if (!this.state.isPlaying || this.state.gameOver) return;
                
                // Process keyboard input
                if (!this.isMobile) {
                    this.input.moveX = 0;
                    this.input.moveZ = 0;
                    
                    // Movement
                    if (this.keys['KeyW'] || this.keys['ArrowUp']) this.input.moveZ = -1;
                    if (this.keys['KeyS'] || this.keys['ArrowDown']) this.input.moveZ = 1;
                    if (this.keys['KeyA'] || this.keys['ArrowLeft']) this.input.moveX = -1;
                    if (this.keys['KeyD'] || this.keys['ArrowRight']) this.input.moveX = 1;
                    
                    // Running
                    this.input.isRunning = this.keys['ShiftLeft'] || this.keys['ShiftRight'];
                    
                    // Pickup
                    this.input.isPickingUp = this.keys['KeyE'] || this.keys['Space'];
                    
                    // Balance control
                    this.input.balanceLeft = this.keys['KeyQ'];
                    this.input.balanceRight = this.keys['KeyR'];
                }
                
                // Normalize diagonal movement
                if (this.input.moveX !== 0 && this.input.moveZ !== 0) {
                    const length = Math.sqrt(this.input.moveX * this.input.moveX + this.input.moveZ * this.input.moveZ);
                    this.input.moveX /= length;
                    this.input.moveZ /= length;
                }
                
                // Apply movement
                if (this.character && (this.input.moveX !== 0 || this.input.moveZ !== 0)) {
                    // Calculate move speed
                    const moveSpeed = this.input.isRunning ? 0.15 : 0.08;
                    
                    // Adjust speed based on bags carried (more bags = slower)
                    const bagSpeedFactor = 1 - (this.state.bagsCarried * 0.1);
                    
                    // Update position
                    const adjustedSpeed = moveSpeed * bagSpeedFactor;
                    this.character.position.x += this.input.moveX * adjustedSpeed;
                    this.character.position.z += this.input.moveZ * adjustedSpeed;
                    
                    // Rotate character in movement direction
                    const targetRotation = Math.atan2(this.input.moveX, -this.input.moveZ);
                    
                    // Smooth rotation
                    let angleDiff = targetRotation - this.character.rotation.y;
                    
                    // Normalize angle difference
                    if (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                    if (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                    
                    // Apply smooth rotation
                    this.character.rotation.y += angleDiff * 0.15;
                    
                    // Play appropriate animation
                    if (this.state.bagsCarried > 0) {
                        this.playAnimation(this.input.isRunning ? 'carry_run' : 'carry_walk');
                    } else {
                        this.playAnimation(this.input.isRunning ? 'run' : 'walk');
                    }
                    
                    // Handle footstep sounds
                    this.handleFootstepSounds();
                    
                    // Check for obstacles
                    this.checkObstacleCollisions();
                    
                } else if (this.character) {
                    // Play idle animation when not moving
                    if (this.state.bagsCarried > 0) {
                        this.playAnimation('carry_idle');
                    } else {
                        this.playAnimation('idle');
                    }
                }
            }

            findClosestBag() {
                if (!this.character || this.availableBags.length === 0) return null;
                
                const characterPos = new THREE.Vector3(
                    this.character.position.x,
                    this.character.position.y,
                    this.character.position.z
                );
                
                let closestBag = null;
                let closestDistance = 3; // Max pickup distance
                
                this.availableBags.forEach(bag => {
                    const bagPos = new THREE.Vector3(
                        bag.position.x,
                        bag.position.y,
                        bag.position.z
                    );
                    
                    const distance = characterPos.distanceTo(bagPos);
                    
                    if (distance < closestDistance) {
                        closestBag = bag;
                        closestDistance = distance;
                    }
                });
                
                return closestBag;
            }
            
            findAvailableAttachPoint() {
                if (!this.attachPoints) return null;
                
                for (const point of this.attachPoints) {
                    if (!point.bag) {
                        return point;
                    }
                }
                
                return null;
            }
            
            pickupBag(bag, attachPoint) {
                // Remove from available bags
                const index = this.availableBags.indexOf(bag);
                if (index > -1) {
                    this.availableBags.splice(index, 1);
                }
                
                // Attach to character
                this.character.add(bag);
                bag.position.copy(attachPoint.point.position);
                
                // Set rotation based on attachment point
                if (attachPoint.hand === 'left') {
                    bag.rotation.set(0, -Math.PI/2, 0);
                } else if (attachPoint.hand === 'right') {
                    bag.rotation.set(0, Math.PI/2, 0);
                } else {
                    bag.rotation.set(0, 0, 0);
                }
                
                // Mark attachment point as used
                attachPoint.bag = bag;
                
                // Add bag to carried bags
                this.bags.push({
                    mesh: bag,
                    attachPoint: attachPoint,
                    weight: bag.userData.weight || 1
                });
                
                // Update bag counter
                this.state.bagsCarried = this.bags.length;
                document.getElementById('bag-counter').textContent = `Bags: ${this.state.bagsCarried}/${this.state.maxBags}`;
                
                // Adjust balance stability based on weight
                this.updateBalanceStability();
                
                // Check win condition
                this.checkWinCondition();
            }
            
            updateBalanceStability() {
                // Base stability
                let stability = 1.0;
                
                // Reduce stability for each bag carried
                this.bags.forEach(bag => {
                    stability -= 0.1 * bag.weight;
                });
                
                // Ensure minimum stability
                stability = Math.max(0.2, stability);
                
                // Update state
                this.state.balanceStability = stability;
            }

            processBalance() {
                if (this.state.gameOver) return;
                
                // Calculate balance change
                let balanceChange = 0;
                
                // Random balance changes (affected by stability)
                balanceChange += (Math.random() - 0.5) * 0.01 * (1 - this.state.balanceStability);
                
                // More balance change when moving
                if (this.input.moveX !== 0 || this.input.moveZ !== 0) {
                    balanceChange += (Math.random() - 0.5) * 0.02 * (1 - this.state.balanceStability);
                    
                    // Even more when running
                    if (this.input.isRunning) {
                        balanceChange += (Math.random() - 0.5) * 0.03 * (1 - this.state.balanceStability);
                    }
                }
                
                // Player control
                if (this.input.balanceLeft) {
                    balanceChange -= 0.01;
                }
                
                if (this.input.balanceRight) {
                    balanceChange += 0.01;
                }
                
                // Apply balance change
                this.state.balance += balanceChange;
                
                // Clamp balance
                this.state.balance = Math.max(0, Math.min(1, this.state.balance));
                
                // Update UI
                this.updateBalanceUI();
                
                // Check if player has fallen
                this.checkBalanceFall();
            }
            
            updateBalanceUI() {
                // Update balance indicator position
                const indicator = document.getElementById('balance-indicator');
                if (indicator) {
                    indicator.style.left = `${this.state.balance * 100}%`;
                }
                
                // Change indicator color based on how far from center
                const distance = Math.abs(this.state.balance - 0.5) * 2; // 0-1 range
                
                if (distance > 0.7) {
                    indicator.style.background = '#ff4444'; // Red for danger
                } else if (distance > 0.4) {
                    indicator.style.background = '#ffaa44'; // Orange for warning
                } else {
                    indicator.style.background = '#ffffff'; // White for safe
                }
            }
            
            checkBalanceFall() {
                // Check if balance is too far from center
                if (this.state.balance < 0.1 || this.state.balance > 0.9) {
                    if (!this.state.isStumbling) {
                        // Start stumbling
                        this.state.isStumbling = true;
                        
                        // Play stumble animation
                        this.playAnimation('stumble');
                        
                        // Play balance warning sound
                        this.playSound('balance');
                        
                        // Display warning
                        this.showFloatingText("Whoa! About to fall!");
                        
                        // Check again after delay to see if player recovered
                        setTimeout(() => {
                            this.checkBalanceRecovery();
                        }, 1500);
                    }
                }
            }
            
            checkBalanceRecovery() {
                // Check if balance is now ok
                if (this.state.balance > 0.2 && this.state.balance < 0.8) {
                    // Recovered
                    this.state.isStumbling = false;
                    this.showFloatingText("Phew! Balanced again!");
                } else {
                    // Still struggling, drop bags
                    this.dropAllBags();
                    
                    // Play fall sound
                    this.playSound('fall');
                    this.playAnimation('fall');
                    
                    // Game over
                    this.state.gameOver = true;
                    
                    // Show game over message
                    this.showFloatingText("You dropped everything! Try again?", 3000);
                    
                    // Restart level after delay
                    setTimeout(() => {
                        this.restartLevel();
                    }, 3000);
                }
            }
        }
        
        // Initialize game when page loads
        window.onload = () => {
            new OneTripGame();
        };
    </script>
</body>
</html> 