<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>One Trip - Full Model Test</title>
    <style>
        body { margin: 0; overflow: hidden; background: #111; }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            color: white;
            text-align: center;
            padding: 10px;
            background: rgba(0,0,0,0.5);
            font-family: Arial, sans-serif;
        }
        #controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        button {
            padding: 5px 10px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }
        label, select { margin: 5px 0; }
    </style>
</head>
<body>
    <div id="info">Loading models to test scaling and animations...</div>
    <div id="controls">
        <label>Animation: 
            <select id="animationSelect">
                <option value="none">None</option>
            </select>
        </label>
        <label>Character Scale: 
            <input type="range" id="characterScale" min="0.1" max="2" step="0.1" value="1">
            <span id="characterScaleValue">1.0</span>
        </label>
        <label>Bag Scale: 
            <input type="range" id="bagScale" min="0.1" max="2" step="0.1" value="1">
            <span id="bagScaleValue">1.0</span>
        </label>
        <label>Environmental Scale: 
            <input type="range" id="envScale" min="0.1" max="2" step="0.1" value="1">
            <span id="envScaleValue">1.0</span>
        </label>
        <button id="resetCamera">Reset Camera</button>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.147.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.147.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.147.0/examples/js/loaders/GLTFLoader.js"></script>

    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        
        // Camera setup
        const camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 15);
        
        // Renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);
        
        // Controls for testing
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        
        // Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(5, 10, 5);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        scene.add(directionalLight);
        
        // Ground
        const groundGeometry = new THREE.PlaneGeometry(100, 100);
        const groundMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x7CFC00,
            roughness: 0.8,
            metalness: 0.1
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);
        
        // Grid helper
        const gridHelper = new THREE.GridHelper(100, 100);
        scene.add(gridHelper);

        // Model groups to control scaling
        const characterGroup = new THREE.Group();
        const bagsGroup = new THREE.Group();
        const environmentGroup = new THREE.Group();
        scene.add(characterGroup);
        scene.add(bagsGroup);
        scene.add(environmentGroup);

        // Models to load
        const models = [
            { name: 'character', file: './onetrip_maincharacter.glb', group: characterGroup, position: [0, 0, 0], scale: 1 },
            { name: 'bag1', file: './newbag.glb', group: bagsGroup, position: [-2, 0, 0], scale: 1 },
            { name: 'bag2', file: './bag2.glb', group: bagsGroup, position: [-3, 0, 0], scale: 1 },
            { name: 'house', file: './house.glb', group: environmentGroup, position: [15, 0, 0], scale: 1 },
            { name: 'car', file: './car.glb', group: environmentGroup, position: [-15, 0, 0], scale: 1 },
            { name: 'tree', file: './tree.glb', group: environmentGroup, position: [8, 0, 8], scale: 1 },
            { name: 'rocks', file: './rocks.glb', group: environmentGroup, position: [-8, 0, -8], scale: 1 },
            { name: 'leaves', file: './leaves.glb', group: environmentGroup, position: [0, 0, -5], scale: 1 }
        ];

        // Animation mixer and actions
        let mixer;
        const actions = {};
        
        // Load models
        const loader = new THREE.GLTFLoader();
        let loadedCount = 0;
        
        models.forEach(model => {
            loader.load(
                model.file,
                (gltf) => {
                    const modelObj = gltf.scene;
                    modelObj.position.set(...model.position);
                    modelObj.scale.set(model.scale, model.scale, model.scale);
                    modelObj.traverse(node => {
                        if (node.isMesh) {
                            node.castShadow = true;
                            node.receiveShadow = true;
                        }
                    });
                    
                    model.group.add(modelObj);
                    
                    // Store model reference
                    window[model.name] = modelObj;
                    
                    // Set up character animations
                    if (model.name === 'character') {
                        mixer = new THREE.AnimationMixer(modelObj);
                        
                        // Create animation actions
                        gltf.animations.forEach(clip => {
                            const action = mixer.clipAction(clip);
                            actions[clip.name] = action;
                            
                            // Add to dropdown
                            const option = document.createElement('option');
                            option.value = clip.name;
                            option.textContent = clip.name;
                            document.getElementById('animationSelect').appendChild(option);
                        });
                        
                        // Play tpose by default
                        if (actions['tpose']) {
                            actions['tpose'].play();
                        }
                        
                        // Store animations for debugging
                        window.mixer = mixer;
                        window.actions = actions;
                    }
                    
                    // Update loaded count
                    loadedCount++;
                    document.getElementById('info').textContent = 
                        `Loaded ${loadedCount}/${models.length} models`;
                    
                    if (loadedCount === models.length) {
                        document.getElementById('info').textContent = 
                            `All models loaded - test scaling and animations`;
                    }
                },
                (xhr) => {
                    const percent = Math.round(xhr.loaded / xhr.total * 100);
                    console.log(`${model.name} ${percent}% loaded`);
                },
                (error) => {
                    console.error(`Error loading ${model.name}:`, error);
                    loadedCount++;
                    document.getElementById('info').textContent += 
                        `\nError loading ${model.name}`;
                }
            );
        });
        
        // UI Controls
        document.getElementById('animationSelect').addEventListener('change', function() {
            const animName = this.value;
            
            // Stop all animations
            for (const name in actions) {
                actions[name].stop();
            }
            
            // Play selected animation
            if (animName !== 'none' && actions[animName]) {
                actions[animName].play();
            }
        });
        
        document.getElementById('characterScale').addEventListener('input', function() {
            const scale = parseFloat(this.value);
            characterGroup.scale.set(scale, scale, scale);
            document.getElementById('characterScaleValue').textContent = scale.toFixed(1);
        });
        
        document.getElementById('bagScale').addEventListener('input', function() {
            const scale = parseFloat(this.value);
            bagsGroup.scale.set(scale, scale, scale);
            document.getElementById('bagScaleValue').textContent = scale.toFixed(1);
        });
        
        document.getElementById('envScale').addEventListener('input', function() {
            const scale = parseFloat(this.value);
            environmentGroup.scale.set(scale, scale, scale);
            document.getElementById('envScaleValue').textContent = scale.toFixed(1);
        });
        
        document.getElementById('resetCamera').addEventListener('click', function() {
            camera.position.set(0, 5, 15);
            camera.lookAt(0, 0, 0);
            controls.target.set(0, 0, 0);
            controls.update();
        });
        
        // Animation loop
        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            
            const delta = clock.getDelta();
            
            // Update animations
            if (mixer) mixer.update(delta);
            
            renderer.render(scene, camera);
        }
        animate();
        
        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html> 