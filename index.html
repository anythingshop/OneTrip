<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>One Trip - Preview</title>
    <style>
        body { margin: 0; overflow: hidden; background: #111; }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            color: white;
            text-align: center;
            padding: 10px;
            font-family: Arial, sans-serif;
            z-index: 100;
            pointer-events: none;
        }
        #controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px;
            font-family: Arial, sans-serif;
            border-radius: 5px;
        }
        #balanceUI {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px;
            font-family: Arial, sans-serif;
            border-radius: 5px;
        }
        #pickupControls {
            position: absolute;
            left: 10px;
            top: 60px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px;
            font-family: Arial, sans-serif;
            border-radius: 5px;
            z-index: 1000;
        }
        select, button, input {
            margin: 5px;
            padding: 5px;
        }
        #balanceMeter {
            width: 200px;
            height: 10px;
            background: rgba(255,255,255,0.3);
            border-radius: 5px;
            margin-top: 5px;
            position: relative;
        }
        #balanceIndicator {
            position: absolute;
            width: 6px;
            height: 100%;
            background: white;
            border-radius: 3px;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
        }
        .balanceZone {
            position: absolute;
            width: 20%;
            height: 100%;
            background: rgba(76,175,80,0.3);
            top: 0;
            left: 40%;
        }
    </style>
</head>
<body>
    <div id="info">Loading models...</div>
    <div id="controls">
        <div>
            <label for="animSelect">Animation: </label>
            <select id="animSelect"></select>
        </div>
        <button id="gameView">Game View</button>
        <button id="resetView">Reset View</button>
        <button id="topView">Top View</button>
        <button id="houseFrontView">House Front View</button>
    </div>
    
    <div id="pickupControls">
        <h3>Pickup Actions</h3>
        <button id="pickupLowBtn">Pickup Low (Ground)</button>
        <button id="pickupHighBtn">Pickup High (Car)</button>
        <button id="attachBagBtn">Attach Bag to Hand</button>
        <button id="detachBagBtn">Detach Bag</button>
    </div>
    
    <div id="balanceUI">
        <h3>Balance System Preview</h3>
        <div>
            <label for="balanceSlider">Balance (0-1): </label>
            <input type="range" id="balanceSlider" min="0" max="100" value="50">
            <span id="balanceValue">0.5</span>
        </div>
        <div id="balanceMeter">
            <div class="balanceZone"></div>
            <div id="balanceIndicator"></div>
        </div>
        <div>
            <button id="toggleBalance">Toggle Balance Effect</button>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.147.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.147.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.147.0/examples/js/loaders/GLTFLoader.js"></script>

    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        
        // Camera setup - intentionally farther back
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.set(0, 10, 30);
        
        // Renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);
        
        // Controls for testing
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.target.set(0, 2, 0);
        controls.update();
        
        // Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(5, 10, 5);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        scene.add(directionalLight);
        
        // Ground
        const groundGeometry = new THREE.PlaneGeometry(200, 200);
        const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x7CFC00 });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);
        
        // Grid helper
        const gridHelper = new THREE.GridHelper(200, 200);
        scene.add(gridHelper);
        
        // Create text labels for each model
        function createLabel(text, position) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 64;
            
            context.fillStyle = 'rgba(0,0,0,0.7)';
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            context.font = '24px Arial';
            context.fillStyle = 'white';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(text, canvas.width/2, canvas.height/2);
            
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.MeshBasicMaterial({
                map: texture,
                transparent: true,
                side: THREE.DoubleSide
            });
            
            const geometry = new THREE.PlaneGeometry(5, 1.25);
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(position.x, position.y + 5, position.z);
            mesh.lookAt(camera.position);
            
            scene.add(mesh);
            return mesh;
        }

        // Add a path/driveway
        function createDriveway() {
            const pathGeometry = new THREE.PlaneGeometry(5, 50);
            const pathMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xBDBDBD,
                roughness: 0.9
            });
            const path = new THREE.Mesh(pathGeometry, pathMaterial);
            path.rotation.x = -Math.PI / 2;
            path.position.set(0, 0.02, 5); // Slightly above ground to prevent z-fighting
            path.receiveShadow = true;
            scene.add(path);
        }
        createDriveway();

        // Models to load with proper positions
        const models = [
            // Character positioned near the car
            { name: 'Character', file: './onetrip_maincharacter.glb', position: [-15, 0, -20], scale: 0.5, rotationY: 0 },
            
            // Car positioned at the beginning of the path
            { name: 'Car', file: './car.glb', position: [-5, 0, -20], scale: 0.5, rotationY: Math.PI/2 },
            
            // House positioned at the end of the path (far in front)
            { name: 'House', file: './house.glb', position: [0, 0, 30], scale: 0.5, rotationY: Math.PI },
            
            // Bags ON TOP of the car - HIGHER Y value
            { name: 'Car Bag 1', file: './newbag.glb', position: [-5, 3.5, -20], scale: 0.4, rotationY: 0 },
            { name: 'Car Bag 2', file: './bag2.glb', position: [-5, 3.5, -19], scale: 0.4, rotationY: Math.PI/4 },
            
            // Bags on the GROUND near character
            { name: 'Ground Bag 1', file: './newbag.glb', position: [-13, 0, -19], scale: 0.4, rotationY: 0 },
            { name: 'Ground Bag 2', file: './bag2.glb', position: [-14, 0, -21], scale: 0.4, rotationY: Math.PI/4 },
            
            // Environment objects properly spaced along the path
            { name: 'Tree', file: './tree.glb', position: [-10, 0, 0], scale: 0.5, rotationY: 0 },
            { name: 'Tree 2', file: './tree.glb', position: [10, 0, 10], scale: 0.4, rotationY: Math.PI/3 },
            { name: 'Rocks', file: './rocks.glb', position: [5, 0, -5], scale: 0.5, rotationY: 0 },
            { name: 'Leaves', file: './leaves.glb', position: [2, 0, 15], scale: 0.5, rotationY: 0 }
        ];

        // Animation variables
        let mixer;
        let animations = {};
        let currentAnimation = 'walk';
        let balanceEnabled = false;
        let balanceValue = 0.5;
        
        // Reference to hand bones for attaching bags
        let leftHand = null;
        let rightHand = null;
        
        // References to bags for attaching
        let groundBag1 = null;
        let groundBag2 = null;
        let carBag1 = null;
        let carBag2 = null;
        
        // Currently attached bag
        let attachedBag = null;

        // Load models
        const loader = new THREE.GLTFLoader();
        let loadedCount = 0;
        let characterModel;
        
        models.forEach(model => {
            // Create label for this model
            const labelMesh = createLabel(model.name, {
                x: model.position[0],
                y: model.position[1],
                z: model.position[2]
            });
            
            loader.load(
                model.file,
                (gltf) => {
                    const modelObj = gltf.scene;
                    
                    // Apply scale and position
                    modelObj.scale.set(model.scale, model.scale, model.scale);
                    modelObj.position.set(...model.position);
                    
                    // Apply rotation if specified
                    if (model.rotationY !== undefined) {
                        modelObj.rotation.y = model.rotationY;
                    }
                    
                    // Enable shadows
                    modelObj.traverse(node => {
                        if (node.isMesh) {
                            node.castShadow = true;
                            node.receiveShadow = true;
                        }
                    });
                    
                    scene.add(modelObj);
                    
                    // Store reference to model
                    if (model.name === 'Ground Bag 1') groundBag1 = modelObj;
                    if (model.name === 'Ground Bag 2') groundBag2 = modelObj;
                    if (model.name === 'Car Bag 1') carBag1 = modelObj;
                    if (model.name === 'Car Bag 2') carBag2 = modelObj;
                    
                    // Store model reference for later use
                    window[model.name.toLowerCase().replace(' ', '_')] = modelObj;
                    
                    // Set up character animations
                    if (model.name === 'Character') {
                        characterModel = modelObj;
                        
                        // Create animation mixer
                        mixer = new THREE.AnimationMixer(modelObj);
                        
                        // Store all animations in a map
                        gltf.animations.forEach(clip => {
                            animations[clip.name] = clip;
                        });
                        
                        // Populate animation dropdown
                        const select = document.getElementById('animSelect');
                        Object.keys(animations).forEach(name => {
                            const option = document.createElement('option');
                            option.value = name;
                            option.textContent = name;
                            select.appendChild(option);
                            
                            // Select walk animation by default
                            if (name === 'walk') {
                                select.value = name;
                            }
                        });
                        
                        // Play walk animation by default
                        playAnimation('walk');
                        
                        // Find hand bones for attaching bags
                        modelObj.traverse(node => {
                            if (node.isBone) {
                                if (node.name === 'mixamorigLeftHand') {
                                    leftHand = node;
                                    console.log('Found left hand bone');
                                }
                                if (node.name === 'mixamorigRightHand') {
                                    rightHand = node;
                                    console.log('Found right hand bone');
                                }
                            }
                        });
                        
                        // Log animations and bones for debugging
                        console.log("Available animations:", Object.keys(animations));
                        console.log("Left hand found:", leftHand !== null);
                        console.log("Right hand found:", rightHand !== null);
                    }
                    
                    // Update loaded count
                    loadedCount++;
                    document.getElementById('info').textContent = 
                        `Loaded ${loadedCount}/${models.length} models`;
                    
                    if (loadedCount === models.length) {
                        document.getElementById('info').textContent = 
                            `All models loaded - Use controls to test animations and balance system`;
                    }
                },
                (xhr) => {
                    console.log(`${model.name} ${Math.round(xhr.loaded / xhr.total * 100)}% loaded`);
                },
                (error) => {
                    console.error(`Error loading ${model.name}:`, error);
                    loadedCount++;
                    document.getElementById('info').textContent += 
                        `\nError loading ${model.name}`;
                }
            );
        });
        
        // Function to play an animation
        function playAnimation(name) {
            if (!mixer || !animations[name]) return;
            
            // Stop all running animations
            mixer.stopAllAction();
            
            // Play the requested animation
            const action = mixer.clipAction(animations[name]);
            action.reset().play();
            currentAnimation = name;
            
            console.log(`Playing animation: ${name}`);
        }
        
        // Function to attach a bag to the character's hand
        function attachBagToHand(bag, hand) {
            if (!bag || !hand || !characterModel) {
                console.warn("Cannot attach bag - missing references");
                return;
            }
            
            // Store original position and parent
            const originalPosition = bag.position.clone();
            const originalRotation = bag.rotation.clone();
            const originalParent = bag.parent;
            
            // Remove from scene
            scene.remove(bag);
            
            // Add to character hand
            hand.add(bag);
            
            // Position relatively
            bag.position.set(0, 0, 0);
            bag.rotation.set(0, 0, 0);
            
            // Store for later
            attachedBag = {
                mesh: bag,
                originalParent: originalParent,
                originalPosition: originalPosition,
                originalRotation: originalRotation
            };
            
            console.log("Bag attached to hand");
        }
        
        // Function to detach the bag
        function detachBag() {
            if (!attachedBag) {
                console.warn("No bag attached");
                return;
            }
            
            const bag = attachedBag.mesh;
            
            // Remove from hand
            bag.parent.remove(bag);
            
            // Add back to scene
            scene.add(bag);
            
            // Restore position
            bag.position.copy(attachedBag.originalPosition);
            bag.rotation.copy(attachedBag.originalRotation);
            
            // Clear reference
            attachedBag = null;
            
            console.log("Bag detached");
        }
        
        // Function to update the balance visualization
        function updateBalanceUI(value) {
            document.getElementById('balanceValue').textContent = value.toFixed(2);
            document.getElementById('balanceIndicator').style.left = `${value * 100}%`;
            
            // Change color based on balance
            const indicator = document.getElementById('balanceIndicator');
            if (value < 0.2 || value > 0.8) {
                indicator.style.background = '#ff4444'; // Red for danger
            } else if (value < 0.3 || value > 0.7) {
                indicator.style.background = '#ffaa44'; // Orange for warning
            } else {
                indicator.style.background = '#ffffff'; // White for safe
            }
            
            // Apply stumble animation when balance is poor
            if (balanceEnabled) {
                if (value < 0.2 || value > 0.8) {
                    playAnimation('stumble_lowerbody');
                } else {
                    playAnimation('walk');
                }
            }
        }
        
        // Set up animation selection
        document.getElementById('animSelect').addEventListener('change', function() {
            playAnimation(this.value);
        });
        
        // Set up pickup buttons
        document.getElementById('pickupLowBtn').addEventListener('click', function() {
            if (animations['pickup_low']) {
                playAnimation('pickup_low');
                console.log("Playing pickup_low animation");
            } else {
                console.warn("pickup_low animation not found");
            }
        });
        
        document.getElementById('pickupHighBtn').addEventListener('click', function() {
            if (animations['pickup_high']) {
                playAnimation('pickup_high');
                console.log("Playing pickup_high animation");
            } else {
                console.warn("pickup_high animation not found");
            }
        });
        
        // Set up bag attachment buttons
        document.getElementById('attachBagBtn').addEventListener('click', function() {
            if (rightHand && groundBag1) {
                attachBagToHand(groundBag1, rightHand);
            } else {
                alert("Cannot attach bag: missing hand or bag reference");
                console.warn("Missing hand or bag references:", {
                    rightHand: rightHand !== null,
                    groundBag1: groundBag1 !== null
                });
            }
        });
        
        document.getElementById('detachBagBtn').addEventListener('click', function() {
            detachBag();
        });
        
        // Set up balance slider
        document.getElementById('balanceSlider').addEventListener('input', function() {
            balanceValue = this.value / 100;
            updateBalanceUI(balanceValue);
        });
        
        // Toggle balance effect
        document.getElementById('toggleBalance').addEventListener('click', function() {
            balanceEnabled = !balanceEnabled;
            this.textContent = balanceEnabled ? 
                'Disable Balance Effect' : 'Enable Balance Effect';
            
            updateBalanceUI(balanceValue);
        });
        
        // Camera view buttons
        document.getElementById('gameView').addEventListener('click', () => {
            // Set camera to game-like third person view
            camera.position.set(-17, 2, -25);
            controls.target.set(-15, 1, -20); // Look at character
            controls.update();
        });
        
        document.getElementById('resetView').addEventListener('click', () => {
            // Reset to overview
            camera.position.set(0, 20, 30);
            controls.target.set(0, 0, 0);
            controls.update();
        });
        
        document.getElementById('topView').addEventListener('click', () => {
            // Birds-eye view
            camera.position.set(0, 50, 0);
            controls.target.set(0, 0, 0);
            controls.update();
        });
        
        document.getElementById('houseFrontView').addEventListener('click', () => {
            // View from house perspective
            camera.position.set(0, 5, 40);
            controls.target.set(0, 5, 0);
            controls.update();
        });
        
        // Animation loop
        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            
            const delta = clock.getDelta();
            
            // Update character animations
            if (mixer) mixer.update(delta);
            
            // Update label orientations
            scene.children.forEach(child => {
                if (child.material && child.material.map && 
                    child.material.map.isCanvasTexture) {
                    child.lookAt(camera.position);
                }
            });
            
            renderer.render(scene, camera);
        }
        animate();
        
        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html> 